<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/ColorLogger.js | typhonjs-color-logger API Document</title>
  <link type="text/css" rel="stylesheet" href="css/mdl/material.min.css">
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/mdl/material.override.css">
  <link type="text/css" rel="stylesheet" href="css/navigation/nav-accordion-style.css">
  <link type="text/css" rel="stylesheet" href="css/navigation/esdoc-nav-style.css">
  <link type="text/css" rel="stylesheet" href="css/scrollbar/webkit-style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">
<div id="contextpopup">
   <button id="context-menu" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect hidden">
      <i class="material-icons">more_vert</i>
   </button>

   <ul class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="context-menu">
      <li class="mdl-menu__item hidden" data-action="openLink">Open on ...</li>
      <li class="mdl-menu__item hidden" data-action="openLink">Open on ...</li>
      <li disabled class="mdl-menu__item hidden">Version: ...</li>
   </ul>
</div>


<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/typhonjs-doc/tjsdoc" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><ul class="nav-accordion-menu animated hidden" data-nav-id="docs-nav-id-1486703418129" data-ice="navData">
<li data-ice="navGroup" class="has-children"><input type="checkbox" name="group-0" id="group-0" checked><label for="group-0" class="nav-header">Local Source</label>
   <ul>
      
   <li data-ice="navFolder" class="has-children"><input type="checkbox" name="folder-0" id="folder-0" checked><label for="folder-0" class="nav-dir-path" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src" data-scm-type="github">src</label>
         <ul>
            
         <li data-ice="navFile" class="has-children nav-accordion-file"><input type="checkbox" name="file-0" id="file-0" checked><label for="file-0" class="nav-file hidden" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/ColorLogger.js" data-scm-type="github">ColorLogger.js</label>
               <ul>
                  
               <li data-ice="doc" class="nav-kind-class"><span data-ice="docLink"><a href="class/src/ColorLogger.js~ColorLogger.html" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/ColorLogger.js#L61" data-scm-type="github">ColorLogger</a></span></li>
</ul>
            </li>
<li data-ice="navFile" class="has-children nav-accordion-file"><input type="checkbox" name="file-1" id="file-1" checked><label for="file-1" class="nav-file hidden" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/TraceFilter.js" data-scm-type="github">TraceFilter.js</label>
               <ul>
                  
               <li data-ice="doc" class="nav-kind-class"><span data-ice="docLink"><a href="class/src/TraceFilter.js~TraceFilter.html" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/TraceFilter.js#L4" data-scm-type="github">TraceFilter</a></span></li>
</ul>
            </li>
</ul>
      </li>
<li data-ice="navFolder" class="has-children"><input type="checkbox" name="folder-1" id="folder-1" checked><label for="folder-1" class="nav-dir-path" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/types" data-scm-type="github">src/types</label>
         <ul>
            
         <li data-ice="navFile" class="has-children nav-accordion-file"><input type="checkbox" name="file-2" id="file-2" checked><label for="file-2" class="nav-file" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/types/types.js" data-scm-type="github">types.js</label>
               <ul>
                  
               <li data-ice="doc" class="nav-kind-typedef"><span data-ice="docLink"><a href="typedef/index.html#static-typedef-ColorLoggerOptions" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/types/types.js" data-scm-type="github">ColorLoggerOptions</a></span></li>
<li data-ice="doc" class="nav-kind-typedef"><span data-ice="docLink"><a href="typedef/index.html#static-typedef-TraceFilterData" data-scm-link="https://github.com/typhonjs-doc/tjsdoc/tree/master/src/types/types.js" data-scm-type="github">TraceFilterData</a></span></li>
</ul>
            </li>
</ul>
      </li>
</ul>
</li>
</ul></nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/ColorLogger.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import TraceFilter from &apos;./TraceFilter.js&apos;;

/**
 * Provides a color coded logger for ANSI terminal usage. In addition to providing a global scope logger
 * `typhonjs-color-logger` is optionally plugin enabled via `typhonjs-plugin-manager` and can self-register on an
 * eventbus with all methods exposed as event bindings.
 *
 * In the future an option to use CSS colors for browser usage will be enabled.
 *
 * There are several format options to display additional data / info including location where the log method is
 * invoked in addition to a time stamp. By default the time stamp option is disabled.
 *
 * When passing in an Error for logging the stack trace of the error will be used for info and trace creation. The
 * `trace` method will automatically generate a stack trace.
 *
 * format:
 * ``[LogLevel] [Time] [File] log text``
 *
 * Log level and color:
 * - fatal: light red
 * - error: red
 * - warn: yellow
 * - info: green
 * - debug: blue
 * - verbose: purple
 * - trace: light cyan
 *
 * Each log method for the log levels above have two alternate versions that are accessed by appending `Compact`,
 * `NoColor` or `Raw` to the method name. Or if using event bindings appending `:compact`, `:nocolor` or `:raw`. The no
 * color option with, well, no color outputting the message with the current log format and the raw format will output
 * just the raw message with no format or color applied.
 *
 * In addition trace inclusive and exclusive regexp filtering is available to eliminate spurious code removing it from
 * the stack trace. By default the typhonjs-color-logger and backbone-esnext-events is excluded from trace results.
 * Additionally the following events from typhonjs-plugin-manager are handled to automatically add and remove trace
 * filters from plugins added &amp; removed via the event bindings: `typhonjs:plugin:manager:added:plugin`,
 * `typhonjs:plugin:manager:plugin:changed:eventbus`, and `typhonjs:plugin:manager:removed:plugin`. To skip auto
 * filter registration for a particular plugin set `logAutoFilter` to false in the associated plugins options.

 * @example
 * import logger from &apos;typhonjs-color-logger&apos;;
 *
 * // simple usage
 * logger.error(&apos;An error occurred!&apos;);
 *
 * @example
 * import PluginManager    from &apos;typhonjs-plugin-manager&apos;;
 * import eventbus         from &apos;backbone-esnext-eventbus&apos;;
 *
 * const pluginManager = new PluginManager({ eventbus });
 *
 * // This will automatically wire up typhonjs-color-logger to the eventbus.
 * pluginManager.add({ name: typhonjs-color-logger });
 *
 * // simple usage
 * eventbus.trigger(&apos;log:error&apos;, &apos;An error occurred!&apos;);
 *
 * @see https://www.npmjs.com/package/typhonjs-plugin-manager
 * @see https://www.npmjs.com/package/backbone-esnext-eventbus
 */
export class ColorLogger
{
   /**
    * Instantiates ColorLogger allowing optional options to be set.
    *
    * @param {ColorLoggerOptions}   [options] - Optional ColorLoggerOptions to set.
    */
   constructor(options = {})
   {
      if (typeof options !== &apos;object&apos;) { throw new TypeError(`&apos;options&apos; is not an object.`); }

      /**
       * Stores ColorLogger options.
       * @type {ColorLoggerOptions}
       * @private
       */
      this._options =
      {
         autoPluginFilters: false,
         consoleEnabled: true,
         filtersEnabled: true,
         showDate: false,
         showInfo: true
      };

      /**
       * @type number
       * @private
       */
      this._logLevel = s_LOG_LEVELS[&apos;info&apos;];

      /**
       * Stores all exclusive trace filters.
       * @type {Map&lt;string, TraceFilter&gt;}
       * @private
       */
      this._exclusiveTraceFilters = new Map();

      /**
       * Stores all inclusive trace filters.
       * @type {Map&lt;string, TraceFilter&gt;}
       * @private
       */
      this._inclusiveTraceFilters = new Map();

      this.addFilter({ type: &apos;exclusive&apos;, name: &apos;typhonjs-color-logger&apos;, filterString: &apos;typhonjs-color-logger&apos; });
      this.addFilter({ type: &apos;exclusive&apos;, name: &apos;backbone-esnext-events&apos;, filterString: &apos;backbone-esnext-events&apos; });

      this.setOptions(options);
   }

   /**
    * Adds a new trace filter.
    *
    * @param {TraceFilterData}   config - The filter config to add.
    *
    * @returns {boolean} True if the filter was added.
    */
   addFilter(config)
   {
      if (typeof config !== &apos;object&apos;) { throw new TypeError(`&apos;filterConfig&apos; is not an &apos;object&apos;.`); }
      if (typeof config.name !== &apos;string&apos;) { throw new TypeError(`&apos;config.name&apos; is not a &apos;string&apos;.`); }
      if (typeof config.filterString !== &apos;string&apos;) { throw new TypeError(`&apos;config.filterString&apos; is not a &apos;string&apos;.`); }

      if (config.type !== &apos;exclusive&apos; &amp;&amp; config.type !== &apos;inclusive&apos;)
      {
         this.error(`&apos;config.type&apos; must be &apos;exclusive&apos; or &apos;inclusive&apos;`);

         return false;
      }

      const filterMap = config.type === &apos;exclusive&apos; ? this._exclusiveTraceFilters : this._inclusiveTraceFilters;

      if (filterMap.has(config.name))
      {
         this.warn(`A filter with name: &apos;${config.name} already exists.`);

         return false;
      }

      const filter = new TraceFilter(config.name, config.filterString);

      if (typeof config.enabled === &apos;boolean&apos;) { filter.enabled = config.enabled; }

      filterMap.set(config.name, filter);

      return true;
   }

   /**
    * Initializes multiple trace filters in a single call.
    *
    * @param {Array&lt;TraceFilterData&gt;} filterConfigs - An array of filter config object hash entries.
    *
    * @returns {boolean} If true all filters were added successfully.
    */
   addFilters(filterConfigs = [])
   {
      if (!Array.isArray(filterConfigs)) { throw new TypeError(`&apos;plugins&apos; is not an array.`); }

      let success = true;

      for (const config of filterConfigs)
      {
         if (!this.addFilter(config)) { success = false; }
      }

      return success;
   }

   /**
    * Applies any exclusive then inclusive filters against a given value.
    *
    * @param {string}   value - A value to test against all filters.
    *
    * @returns {boolean} If true then the value matched a filter.
    * @private
    */
   _applyFilters(value)
   {
      // Early out if there are no trace filters.
      if (this._exclusiveTraceFilters.size === 0 &amp;&amp; this._inclusiveTraceFilters.size === 0) { return false; }

      // Start filtered as false and if an exclusive filter matches then set it to true..
      let filtered = false;

      for (const filter of this._exclusiveTraceFilters.values())
      {
         if (filter.test(value)) { filtered = true; break; }
      }

      // If an exclusive filter matched then exit early.
      if (filtered) { return filtered; }

      // Invert filtered to being true if there are any inclusive filters. If an inclusive filter matches then set
      // it to false.
      filtered = this._inclusiveTraceFilters.size &gt; 0;

      for (const filter of this._inclusiveTraceFilters.values())
      {
         if (filter.test(value)) { filtered = false; break; }
      }

      return filtered;
   }


   /**
    * Gets the filter data for a trace filter by name.
    *
    * @param {boolean|undefined} enabled - If enabled is a boolean it will return filters given their enabled state.
    *
    * @returns {Array&lt;TraceFilterData&gt;}
    */
   getAllFilterData(enabled = void 0)
   {
      if (typeof enabled !== &apos;boolean&apos; &amp;&amp; typeof enabled !== &apos;undefined&apos;)
      {
         throw new TypeError(`&apos;enabled&apos; is not a &apos;boolean&apos; or &apos;undefined&apos;.`);
      }

      const results = [];

      // Return all filter data if enabled is not defined.
      const allFilters = typeof enabled === &apos;undefined&apos;;

      for (const filter of this._exclusiveTraceFilters.values())
      {
         if (allFilters || filter.enabled === enabled)
         {
            results.push(
            {
               enabled: filter.enabled,
               filterString: filter.filterString,
               name: filter.name,
               type: &apos;exclusive&apos;
            });
         }
      }

      for (const filter of this._inclusiveTraceFilters.values())
      {
         if (allFilters || filter.enabled === enabled)
         {
            results.push(
            {
               enabled: filter.enabled,
               filterString: filter.filterString,
               name: filter.name,
               type: &apos;inclusive&apos;
            });
         }
      }

      return results;
   }

   /**
    * Gets the filter data for a trace filter by name.
    *
    * @param {string}   type - The type of filter; must be &apos;exclusive&apos; or &apos;inclusive&apos;.
    *
    * @param {string}   name - The name of the filter.
    *
    * @returns {TraceFilterData|undefined}
    */
   getFilterData(type, name)
   {
      if (type !== &apos;exclusive&apos; &amp;&amp; type !== &apos;inclusive&apos;)
      {
         throw new Error(`&apos;type&apos; must be &apos;exclusive&apos; or &apos;inclusive&apos;`);
      }

      const filterMap = type === &apos;exclusive&apos; ? this._exclusiveTraceFilters : this._inclusiveTraceFilters;

      const filter = filterMap.get(name);

      if (filter instanceof TraceFilter)
      {
         return {
            enabled: filter.enabled,
            filterString: filter.filterString,
            name: filter.name,
            type
         };
      }

      return void 0;
   }

   /**
    * Gets a trace filter enabled state.
    *
    * @param {string}   type - The type of filter; must be &apos;exclusive&apos; or &apos;inclusive&apos;.
    *
    * @param {string}   name - The name of the filter.
    *
    * @returns {boolean} True if the filter enabled state was modified.
    */
   getFilterEnabled(type, name)
   {
      if (type !== &apos;exclusive&apos; &amp;&amp; type !== &apos;inclusive&apos;)
      {
         throw new Error(`&apos;type&apos; must be &apos;exclusive&apos; or &apos;inclusive&apos;`);
      }

      const filterMap = type === &apos;exclusive&apos; ? this._exclusiveTraceFilters : this._inclusiveTraceFilters;

      const filter = filterMap.get(name);

      if (filter instanceof TraceFilter)
      {
         return filter.enabled;
      }

      return false;
   }

   /**
    * Get the log level
    *
    * @returns {*}
    */
   getLogLevel()
   {
      return this._logLevel;
   }

   /**
    * Returns a copy of the logger options.
    *
    * @returns {ColorLoggerOptions} - Logger options.
    */
   getOptions()
   {
      return JSON.parse(JSON.stringify(this._options));
   }

   /**
    * Generates log information from where the logger invocation originated.
    *
    * @param {Error}    error - An optional Error to trace instead of artificially generating one.
    *
    * @param {boolean}  [isTrace=false] - If true then process remaining trace.
    *
    * @return {{info: string, trace: String[]}} info: file name and line number; trace: remaining stack trace if
    *                                           enabled.
    * @private
    */
   getTraceInfo(error, isTrace = false)
   {
      let info = &apos;no stack trace&apos;;
      const trace = [];

      let processError = error;

      if (!(processError instanceof Error))
      {
         try { throw new Error(); }
         catch (err) { processError = err; }
      }

      // Make sure there is a entry in `processError`.
      if (typeof processError.stack === &apos;string&apos;)
      {
         const lines = processError.stack.split(&apos;\n&apos;);

         let cntr = 0;

         for (; cntr &lt; lines.length; cntr++)
         {
            if (this._options.filtersEnabled &amp;&amp; this._applyFilters(lines[cntr])) { continue; }

            const matched = lines[cntr].match(/([\w\d\-_.]*:\d+:\d+)/);

            if (matched !== null)
            {
               info = matched[1];
               break;
            }
         }

         // If gathering trace info continue to push lines to `trace`. Ignoring any lines that originate from
         // ColorLogger or `backbone-esnext-events` plus an optional filter.
         if (isTrace)
         {
            for (; cntr &lt; lines.length; cntr++)
            {
               if (this._options.filtersEnabled &amp;&amp; this._applyFilters(lines[cntr])) { continue; }

               trace.push(lines[cntr]);
            }
         }
      }

      return { info, trace };
   }

   /**
    * Returns whether the given log level is enabled.
    *
    * @param {string}   level - log level
    * @returns {boolean}
    */
   isLevelEnabled(level)
   {
      const requestedLevel = s_LOG_LEVELS[level];

      if (typeof requestedLevel === &apos;undefined&apos; || requestedLevel === null)
      {
         console.log(`isLevelEnabled - unknown log level: ${level}`);
         return false;
      }

      return s_IS_LEVEL_ENABLED(this.getLogLevel(), requestedLevel);
   }

   /**
    * Returns true if the given level is a valid log level.
    *
    * @param {string}   level - The log level string to test.
    *
    * @returns {boolean}
    */
   isValidLogLevel(level)
   {
      return typeof level === &apos;string&apos; &amp;&amp; typeof s_LOG_LEVELS[level] === &apos;number&apos;;
   }

   /**
    * Display log message.
    *
    * @param {string}   level - log level: `fatal`, `error`, `warn`, `info`, `debug`, `verbose`, `trace`.
    * @param {boolean}  [compact=false] - If true then all JSON object conversion is compacted.
    * @param {boolean}  [nocolor=false] - If true then no color is applied.
    * @param {boolean}  [raw=false] - If true then just the raw message is logged at the given level.
    *
    * @param {...*}     msg - log message.
    *
    * @returns {string|undefined} formatted log message or undefined if log level is not enabled.
    * @private
    */
   _output(level, compact = false, nocolor = false, raw = false, ...msg)
   {
      if (!s_IS_LEVEL_ENABLED(this.getLogLevel(), s_LOG_LEVELS[level])) { return; }

      const text = [];

      const isTrace = level === &apos;trace&apos;;

      for (const m of msg)
      {
         if (typeof m === &apos;object&apos; &amp;&amp; !(m instanceof Error))
         {
            text.push(compact ? JSON.stringify(m) : JSON.stringify(m, null, 3));
         }
         else if (m instanceof Error)
         {
            const result = this.getTraceInfo(m, true);

            text.push(`${m.message}\n${result.trace.join(&apos;\n&apos;)}`);
         }
         else
         {
            text.push(m);
         }
      }

      const color = nocolor ? &apos;&apos; : s_LEVEL_TO_COLOR[level];

      const spacer = raw ? &apos;&apos; : &apos; &apos;;

      let info = &apos;&apos;;
      let trace = &apos;&apos;;

      if (this._options.showInfo &amp;&amp; !raw)
      {
         const infoSpace = nocolor ? &apos;&apos; : &apos; &apos;;

         const result = this.getTraceInfo(void 0, isTrace);

         info = `${infoSpace}[${result.info}]`;
         trace = isTrace ? `\n${result.trace.join(&apos;\n&apos;)}\n` : &apos;&apos;;
      }

      let now = &apos;&apos;;

      if (this._options.showDate &amp;&amp; !raw)
      {
         const d = new Date();

         let month = d.getMonth() + 1;
         if (month &lt; 10) { month = `0${month}`; }

         let date = d.getDate();
         if (date &lt; 10) { date = `0${date}`; }

         let hour = d.getHours();
         if (hour &lt; 10) { hour = `0${hour}`; }

         let minutes = d.getMinutes();
         if (minutes &lt; 10) { minutes = `0${minutes}`; }

         let sec = d.getSeconds();
         if (sec &lt; 10) { sec = `0${sec}`; }

         now = ` [${d.getFullYear()}-${month}-${date}T${hour}:${minutes}:${sec}.${d.getMilliseconds()}Z]`;
      }

      const log = `${color}${now}${info}${spacer}${trace}${text.join(&apos;\n&apos;)}[0m`;

      if (this._options.consoleEnabled)
      {
         console.log(log);
      }

      return log;
   }

   /**
    * Removes all trace filters.
    */
   removeAllFilters()
   {
      this._exclusiveTraceFilters.clear();
      this._inclusiveTraceFilters.clear();
   }

   /**
    * Removes a trace filter by name
    *
    * @param {string}   type - The type of filter; must be &apos;exclusive&apos; or &apos;inclusive&apos;.
    *
    * @param {string}   name - The name of the filter.
    *
    * @returns {boolean} True if the filter was removed.
    */
   removeFilter(type, name)
   {
      if (type !== &apos;exclusive&apos; &amp;&amp; type !== &apos;inclusive&apos;)
      {
         throw new Error(`&apos;type&apos; must be &apos;exclusive&apos; or &apos;inclusive&apos;`);
      }

      const filterMap = type === &apos;exclusive&apos; ? this._exclusiveTraceFilters : this._inclusiveTraceFilters;

      return filterMap.delete(name);
   }

   /**
    * Sets a trace filters enabled state.
    *
    * @param {string}   type - The type of filter; must be &apos;exclusive&apos; or &apos;inclusive&apos;.
    *
    * @param {string}   name - The name of the filter.
    *
    * @param {boolean}  enabled - The new enabled state.
    *
    * @returns {boolean} True if the filter enabled state was modified.
    */
   setFilterEnabled(type, name, enabled)
   {
      if (type !== &apos;exclusive&apos; &amp;&amp; type !== &apos;inclusive&apos;)
      {
         throw new Error(`&apos;type&apos; must be &apos;exclusive&apos; or &apos;inclusive&apos;`);
      }

      const filterMap = type === &apos;exclusive&apos; ? this._exclusiveTraceFilters : this._inclusiveTraceFilters;

      const filter = filterMap.get(name);

      if (filter instanceof TraceFilter)
      {
         filter.enabled = enabled;
         return true;
      }

      return false;
   }

   /**
    * Sets the current log level.
    *
    * @param {string}   level - log level
    * @returns {boolean}
    */
   setLogLevel(level)
   {
      const requestedLevel = s_LOG_LEVELS[level];

      if (typeof requestedLevel === &apos;undefined&apos; || requestedLevel === null)
      {
         console.log(`setLogLevel - unknown log level: ${level}`);
         return false;
      }

      this._logLevel = requestedLevel;
      return true;
   }

   /**
    * Set optional parameters.
    *
    * @param {ColorLoggerOptions} options - Defines optional parameters to set.
    */
   setOptions(options = {})
   {
      if (typeof options !== &apos;object&apos;) { throw new TypeError(`&apos;options&apos; is not an object.`); }

      if (typeof options.autoPluginFilters === &apos;boolean&apos;)
      {
         this._options.autoPluginFilters = options.autoPluginFilters;
      }

      if (typeof options.consoleEnabled === &apos;boolean&apos;) { this._options.consoleEnabled = options.consoleEnabled; }
      if (typeof options.filtersEnabled === &apos;boolean&apos;) { this._options.filtersEnabled = options.filtersEnabled; }
      if (typeof options.showDate === &apos;boolean&apos;) { this._options.showDate = options.showDate; }
      if (typeof options.showInfo === &apos;boolean&apos;) { this._options.showInfo = options.showInfo; }
   }

   // Logging methods -----------------------------------------------------------------------------------------------

   /**
    * Display fatal (light red) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   fatal(...msg) { return this._output(&apos;fatal&apos;, false, false, false, ...msg); }

   /**
    * Display fatal (light red) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   fatalCompact(...msg) { return this._output(&apos;fatal&apos;, true, false, false, ...msg); }

   /**
    * Display fatal log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   fatalNoColor(...msg) { return this._output(&apos;fatal&apos;, false, true, false, ...msg); }

   /**
    * Display raw fatal log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   fatalRaw(...msg) { return this._output(&apos;fatal&apos;, false, true, true, ...msg); }

   /**
    * Display error(red) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   error(...msg) { return this._output(&apos;error&apos;, false, false, false, ...msg); }

   /**
    * Display error(red) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   errorCompact(...msg) { return this._output(&apos;error&apos;, true, false, false, ...msg); }

   /**
    * Display error log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   errorNoColor(...msg) { return this._output(&apos;error&apos;, false, true, false, ...msg); }

   /**
    * Display raw error log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   errorRaw(...msg) { return this._output(&apos;error&apos;, false, true, true, ...msg); }

   /**
    * Display warning (yellow) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   warn(...msg) { return this._output(&apos;warn&apos;, false, false, false, ...msg); }

   /**
    * Display warning (yellow) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   warnCompact(...msg) { return this._output(&apos;warn&apos;, true, false, false, ...msg); }

   /**
    * Display warning log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   warnNoColor(...msg) { return this._output(&apos;warn&apos;, false, true, false, ...msg); }

   /**
    * Display raw warn log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   warnRaw(...msg) { return this._output(&apos;warn&apos;, false, true, true, ...msg); }

   /**
    * Display info (green) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   info(...msg) { return this._output(&apos;info&apos;, false, false, false, ...msg); }

   /**
    * Display info (green) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   infoCompact(...msg) { return this._output(&apos;info&apos;, true, false, false, ...msg); }

   /**
    * Display info log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   infoNoColor(...msg) { return this._output(&apos;info&apos;, false, true, false, ...msg); }

   /**
    * Display raw info log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   infoRaw(...msg) { return this._output(&apos;info&apos;, false, true, true, ...msg); }

   /**
    * Display debug (blue) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   debug(...msg) { return this._output(&apos;debug&apos;, false, false, false, ...msg); }

   /**
    * Display debug (blue) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   debugCompact(...msg) { return this._output(&apos;debug&apos;, true, false, false, ...msg); }

   /**
    * Display debug log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   debugNoColor(...msg) { return this._output(&apos;debug&apos;, false, true, false, ...msg); }

   /**
    * Display raw debug log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   debugRaw(...msg) { return this._output(&apos;debug&apos;, false, true, true, ...msg); }

   /**
    * Display verbose (purple) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   verbose(...msg) { return this._output(&apos;verbose&apos;, false, false, false, ...msg); }

   /**
    * Display verbose (purple) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   verboseCompact(...msg) { return this._output(&apos;verbose&apos;, true, false, false, ...msg); }

   /**
    * Display verbose log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   verboseNoColor(...msg) { return this._output(&apos;verbose&apos;, false, true, false, ...msg); }

   /**
    * Display raw verbose log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   verboseRaw(...msg) { return this._output(&apos;verbose&apos;, false, true, true, ...msg); }

   /**
    * Display trace (purple) log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   trace(...msg) { return this._output(&apos;trace&apos;, false, false, false, ...msg); }

   /**
    * Display trace (purple) log; objects compacted.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   traceCompact(...msg) { return this._output(&apos;trace&apos;, true, false, false, ...msg); }

   /**
    * Display trace log.
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   traceNoColor(...msg) { return this._output(&apos;trace&apos;, false, true, false, ...msg); }

   /**
    * Display raw trace log (no style / no color).
    * @param {...*} msg - log message.
    * @returns {string} formatted log message.
    */
   traceRaw(...msg) { return this._output(&apos;trace&apos;, false, true, true, ...msg); }
}

/**
 * ASCII ESCAPE SEQUENCE https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
 * @type {{n: string, v: string, d: string, i: string, w: string, e: string}}
 */
const s_LEVEL_TO_COLOR =
{
   fatal: &apos;[1;31m[F]&apos;, // light red
   error: &apos;[31m[E]&apos;,   // red
   warn: &apos;[33m[W]&apos;,    // yellow
   info: &apos;[32m[I]&apos;,    // green
   debug: &apos;[34m[D]&apos;,   // blue
   verbose: &apos;[35m[V]&apos;, // purple
   trace: &apos;[1;36m[T]&apos;  // light cyan
};

/**
 * Stores the log level name to level value.
 * @type {{off: number, fatal: number, error: number, warn: number, info: number, verbose: number, debug: number, trace: number, all: number}}
 */
const s_LOG_LEVELS =
{
   off: 8,
   fatal: 7,
   error: 6,
   warn: 5,
   info: 4,
   verbose: 3,
   debug: 2,
   trace: 1,
   all: 0
};

/**
 * Validates that the current / requested levels are numbers and that current level is less than requested level.
 *
 * @param {number}   currentLevel - The current ColorLogger level.
 *
 * @param {number}   requestedLevel - The requested level to log.
 *
 * @returns {boolean} True if the requested level is greater than or equal to the current enabled log level.
 */
const s_IS_LEVEL_ENABLED = (currentLevel, requestedLevel) =&gt;
{
   return Number.isInteger(currentLevel) &amp;&amp; Number.isInteger(requestedLevel) &amp;&amp; currentLevel &lt;= requestedLevel;
};

/**
 * The default logger instance.
 * @type {ColorLogger}
 */
const logger = new ColorLogger();

export default logger;

/**
 * Wires up Logger on the plugin eventbus.
 *
 * @param {PluginEvent} ev - The plugin event.
 *
 * @see https://www.npmjs.com/package/typhonjs-plugin-manager
 *
 * @ignore
 */
export function onPluginLoad(ev)
{
   const eventbus = ev.eventbus;

   let eventPrepend = &apos;&apos;;

   const options = ev.pluginOptions;

   // Apply any plugin options.
   if (typeof options === &apos;object&apos;)
   {
      logger.setOptions(options);

      // If `eventPrepend` is defined then it is prepended before all event bindings.
      if (typeof options.eventPrepend === &apos;string&apos;) { eventPrepend = `${options.eventPrepend}:`; }

      if (Array.isArray(options.filterConfigs)) { logger.addFilters(options.filterConfigs); }
   }

   eventbus.on(`${eventPrepend}log:fatal`, logger.fatal, logger);
   eventbus.on(`${eventPrepend}log:fatal:compact`, logger.fatalCompact, logger);
   eventbus.on(`${eventPrepend}log:fatal:nocolor`, logger.fatalNoColor, logger);
   eventbus.on(`${eventPrepend}log:fatal:raw`, logger.fatalRaw, logger);
   eventbus.on(`${eventPrepend}log:error`, logger.error, logger);
   eventbus.on(`${eventPrepend}log:error:compact`, logger.errorCompact, logger);
   eventbus.on(`${eventPrepend}log:error:nocolor`, logger.errorNoColor, logger);
   eventbus.on(`${eventPrepend}log:error:raw`, logger.errorRaw, logger);
   eventbus.on(`${eventPrepend}log:warn`, logger.warn, logger);
   eventbus.on(`${eventPrepend}log:warn:compact`, logger.warnCompact, logger);
   eventbus.on(`${eventPrepend}log:warn:nocolor`, logger.warnNoColor, logger);
   eventbus.on(`${eventPrepend}log:warn:raw`, logger.warnRaw, logger);
   eventbus.on(`${eventPrepend}log:info`, logger.info, logger);
   eventbus.on(`${eventPrepend}log:info:compact`, logger.infoCompact, logger);
   eventbus.on(`${eventPrepend}log:info:nocolor`, logger.infoNoColor, logger);
   eventbus.on(`${eventPrepend}log:info:raw`, logger.infoRaw, logger);
   eventbus.on(`${eventPrepend}log:debug`, logger.debug, logger);
   eventbus.on(`${eventPrepend}log:debug:compact`, logger.debugCompact, logger);
   eventbus.on(`${eventPrepend}log:debug:nocolor`, logger.debugNoColor, logger);
   eventbus.on(`${eventPrepend}log:debug:raw`, logger.debugRaw, logger);
   eventbus.on(`${eventPrepend}log:verbose`, logger.verbose, logger);
   eventbus.on(`${eventPrepend}log:verbose:compact`, logger.verboseCompact, logger);
   eventbus.on(`${eventPrepend}log:verbose:nocolor`, logger.verboseNoColor, logger);
   eventbus.on(`${eventPrepend}log:verbose:raw`, logger.verboseRaw, logger);
   eventbus.on(`${eventPrepend}log:trace`, logger.trace, logger);
   eventbus.on(`${eventPrepend}log:trace:compact`, logger.traceCompact, logger);
   eventbus.on(`${eventPrepend}log:trace:nocolor`, logger.traceNoColor, logger);
   eventbus.on(`${eventPrepend}log:trace:raw`, logger.traceRaw, logger);

   eventbus.on(`${eventPrepend}log:add:filter`, logger.addFilter, logger);
   eventbus.on(`${eventPrepend}log:get:all:filter:data`, logger.getAllFilterData, logger);
   eventbus.on(`${eventPrepend}log:get:filter:data`, logger.getFilterData, logger);
   eventbus.on(`${eventPrepend}log:get:filter:enabled`, logger.getFilterEnabled, logger);
   eventbus.on(`${eventPrepend}log:get:level`, logger.getLogLevel, logger);
   eventbus.on(`${eventPrepend}log:get:options`, logger.getOptions, logger);
   eventbus.on(`${eventPrepend}log:get:trace:info`, logger.getTraceInfo, logger);
   eventbus.on(`${eventPrepend}log:is:level:enabled`, logger.isLevelEnabled, logger);
   eventbus.on(`${eventPrepend}log:is:valid:log:level`, logger.isValidLogLevel, logger);
   eventbus.on(`${eventPrepend}log:remove:all:filters`, logger.removeAllFilters, logger);
   eventbus.on(`${eventPrepend}log:remove:filter`, logger.removeFilter, logger);
   eventbus.on(`${eventPrepend}log:set:filter:enabled`, logger.setFilterEnabled, logger);
   eventbus.on(`${eventPrepend}log:set:level`, logger.setLogLevel, logger);
   eventbus.on(`${eventPrepend}log:set:options`, logger.setOptions, logger);

   // Add plugin auto filter support for added plugins.
   eventbus.on(&apos;typhonjs:plugin:manager:added:plugin&apos;, (plugin) =&gt;
   {
      // Always ignore adding an inclusive filter when typhonjs-color-logger is added.
      if (typeof plugin.name === &apos;string&apos; &amp;&amp; plugin.name === &apos;typhonjs-color-logger&apos;) { return; }

      if (logger.getOptions().autoPluginFilters &amp;&amp; typeof plugin.scopedName === &apos;string&apos; &amp;&amp;
       typeof plugin.targetEscaped === &apos;string&apos; &amp;&amp; typeof plugin.options === &apos;object&apos;)
      {
         // Skip auto filtering if the given plugin has logAutoFilter defined and it is false.
         if (typeof plugin.options.logAutoFilter === &apos;boolean&apos; &amp;&amp; !plugin.options.logAutoFilter) { return; }

         // Allow plugin options to override default &apos;inclusive&apos; filter potentially making it &apos;exclusive&apos;.
         const type = plugin.options.logAutoFilterType !== &apos;exclusive&apos; ? &apos;inclusive&apos; : &apos;exclusive&apos;;

         logger.addFilter({ type, name: plugin.scopedName, filterString: plugin.targetEscaped });
      }
   });

   // Add plugin auto filter re-registration support when plugin managers change eventbus / event binding prepend.
   eventbus.on(&apos;typhonjs:plugin:manager:plugin:changed:eventbus&apos;, (plugin) =&gt;
   {
      if (logger.getOptions().autoPluginFilters &amp;&amp; typeof plugin.scopedName === &apos;string&apos; &amp;&amp;
       typeof plugin.targetEscaped === &apos;string&apos; &amp;&amp; typeof plugin.options === &apos;object&apos;)
      {
         // Skip auto filtering if the given plugin has logAutoFilter defined and it is false.
         if (typeof plugin.options.logAutoFilter === &apos;boolean&apos; &amp;&amp; !plugin.options.logAutoFilter) { return; }

         // Allow plugin options to override default &apos;inclusive&apos; filter potentially making it &apos;exclusive&apos;.
         const type = plugin.options.logAutoFilterType !== &apos;exclusive&apos; ? &apos;inclusive&apos; : &apos;exclusive&apos;;

         logger.removeFilter(type, plugin.oldScopedName);
         logger.addFilter({ type, name: plugin.newScopedName, filterString: plugin.targetEscaped });
      }
   });

   // Add plugin auto filter support for removed plugins.
   eventbus.on(&apos;typhonjs:plugin:manager:removed:plugin&apos;, (plugin) =&gt;
   {
      if (logger.getOptions().autoPluginFilters &amp;&amp; typeof plugin.scopedName === &apos;string&apos; &amp;&amp;
       typeof plugin.options === &apos;object&apos;)
      {
         // Skip auto filtering if the given plugin has logAutoFilter defined and it is false.
         if (typeof plugin.options.logAutoFilter === &apos;boolean&apos; &amp;&amp; !plugin.options.logAutoFilter) { return; }

         // Allow plugin options to override default &apos;inclusive&apos; filter potentially making it &apos;exclusive&apos;.
         const type = plugin.options.logAutoFilterType !== &apos;exclusive&apos; ? &apos;inclusive&apos; : &apos;exclusive&apos;;

         logger.removeFilter(type, plugin.scopedName);
      }
   });
}

/**
 * Removes any trace filters when unloading plugin.
 *
 * @param {PluginEvent} ev - The plugin event.
 *
 * @see https://www.npmjs.com/package/typhonjs-plugin-manager
 *
 * @ignore
 */
export function onPluginUnload()
{
   logger.removeAllFilters();
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.0-alpha)</span></a>
</footer>

<script src="script/jquery/jquery.min.js"></script>
<script src="script/navigation/enhancednav.js"></script>
<script defer src="script/mdl/material.min.js"></script>
<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
