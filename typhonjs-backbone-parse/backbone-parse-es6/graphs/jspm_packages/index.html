<html>
<head>
   <title>backbone-parse-es6</title>

   <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
   <link rel="stylesheet" href="https://code.getmdl.io/1.1.3/material.indigo-pink.min.css">

   <style>
      body {
   background: #fff;
   padding:0;
   margin:0;
   font-family: 'Roboto', sans-serif;
   overflow: hidden;

   -webkit-user-select: none;
   -khtml-user-select: none;
   -moz-user-select: none;
   user-select: none;
}

.graph {
   position: fixed;
   top: 0;
   left: 0;
   width:100%;
   height: 100%;
   overflow: hidden;
}

svg {
   position: fixed;
   top: 0;
   left: 0;
   height: 100%;
   width: 100%;
   cursor: move;
}

g.dimmed  {
   stroke-opacity: 0.05;
}

g.dimmed text.shadow {
   stroke-opacity: 0;
}

circle {
   fill: #ccc;
   stroke: #333;
   stroke-width: 2px;
   cursor: hand;
}

circle.npm {
   fill: rgb(237,151,158);
}

circle.github {
   fill: rgb(255,210,87);
}

circle.selected {
   fill: #00ff00;
}

text {
   font: 10px sans-serif;
   pointer-events: none;
}

text.shadow {
   stroke: #fff;
   stroke-width: 3px;
   stroke-opacity: .8;
}

text.isAliased {
   fill: #ff0000;
}

path.link {
   fill: none;
   stroke: #666;
   stroke-width: 1.5px;
}

path.link.licensing {
   stroke: green;
}

path.link.resolved {
   stroke-dasharray: 0,2 1;
}

.control-button {
   position: relative;
   float: left;
   background: rgba(240, 240, 240, 0.9);
   padding: 5px;
   margin-top: 5px;
   margin-left: 10px;
   border-radius: 7px;
   z-index: 10;
}

.control-level {
   position: relative;
   float: left;
   width: 200px;
   background: rgba(240, 240, 240, 0.9);
   padding: 16px 5px 16px 5px;
   margin-top: 5px;
   margin-left: 10px;
   border-radius: 7px;
   z-index: 10;
}

.control-toggles {
   position: relative;
   float: left;
   background: rgba(240, 240, 240, 0.9);
   padding: 13px 18px 13px 18px;
   margin-top: 5px;
   margin-left: 10px;
   border-radius: 7px;
   z-index: 10;
}

.control-table {
   position: relative;
   clear: both;
   float: left;
   background: rgba(240, 240, 240, 0.9);
   padding: 8px;
   margin-top: 10px;
   margin-left: 10px;
   border-radius: 7px;
   z-index: 10;
}

.control-table-inner {
   position: relative;
   /*padding: 0 5px;*/
   overflow-x: hidden;
   overflow-y: auto;
}

.flex-center-left {
   display: flex;
   align-items: center;
   justify-content: left;
}

td.isAliased {
   color: #f00;
}

.material-icon-blue {
   color: #3f51b5;
}

.mdl-menu {
   padding: 0;
}

.mdl-menu__item {
   height: 32px;
   line-height: 32px;
   padding: 0 8px;
}

li.mdl-menu__item:hover
{
   background-color: #87cefa;
}

.mdl-data-table {
   background-color: rgba(255, 255, 255, 0.2);
}

.mdl-data-table tbody tr {
   height: 14px;
}

.mdl-data-table tbody tr:hover
{
   background-color: rgba(255, 255, 255, 0.8);
   cursor: pointer;
}

.mdl-data-table td
{
   height: 14px;
   line-height: 14px;
   padding: 4px 8px;
   vertical-align: bottom;
}

.mdl-data-table th {
   height: 14px;
   line-height: 14px;
   padding: 8px 4px 8px 16px;
   vertical-align: bottom;
}

.mdl-data-table thead th:hover
{
   background-color: rgba(255, 255, 255, 0.8);
   cursor: pointer;
}

.mdl-data-table th:first-of-type
{
   padding-left: 16px;
}

.mdl-data-table th:last-of-type
{
   padding-right: 8px;
}

.mdl-data-table td:first-of-type
{
   padding-left: 12px;
}

.mdl-data-table td:last-of-type
{
   padding-right: 12px;
}

.mdl-data-table td:not(:first-child), .mdl-data-table th:not(:first-child)
{
   border-left: 1px solid rgba(100, 100, 100, 0.1);
}

.tablesorter-stickyHeader {
   background-color: rgb(245, 245, 245);
}

th.tablesorter-header {
   background-image: url(data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw==);
   font-weight: bold;
   background-repeat: no-repeat;
   background-position: center left;
   outline : none;
}

th.tablesorter-headerAsc {
   background-image: url(data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjB+gC+jP2ptn0WskLQA7);
   outline : none;
}

th.tablesorter-headerDesc {
   background-image: url(data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjI8Bya2wnINUMopZAQA7);
   outline : none;
}

/**
 * Scrollbars
 */
::-webkit-scrollbar
{
   height: 10px !important;
   overflow: visible !important;
   width: 10px !important;
}

::-webkit-scrollbar-thumb
{
   background: -webkit-linear-gradient(left, rgba(225,225,225,0.9) 0%,rgba(240,240,240,0.9) 100%) !important;
   background-clip: padding-box !important;
   border: 2px solid transparent !important;
   border-image: initial !important;
   min-height: 28px !important;
   padding: 100px 0 0 !important;
   box-shadow: rgba(0, 0, 0, 0.0980392) 1px 1px 0 inset, rgba(0, 0, 0, 0.0666667) 0 -1px 0 inset !important;

   -moz-border-radius: 5px !important;    /* Firefox 3.6-, removed in Firefox 13 */
   -webkit-border-radius: 5px !important; /* Safari 4-, Chrome 3- */
   border-radius: 5px !important;         /* Firefox 4+, Safari 5+, Chrome 4+, Opera 10.5+, IE9+ */
}

::-webkit-scrollbar-thumb:hover
{
   background: -webkit-linear-gradient(left, rgba(235,235,235,0.9) 0%,rgba(250,250,250,0.9) 100%) !important;
   background-clip: padding-box !important;

   -moz-border-radius: 5px !important;    /* Firefox 3.6-, removed in Firefox 13 */
   -webkit-border-radius: 5px !important; /* Safari 4-, Chrome 3- */
   border-radius: 5px !important;         /* Firefox 4+, Safari 5+, Chrome 4+, Opera 10.5+, IE9+ */
}

::-webkit-scrollbar-thumb:window-inactive
{
   background: -webkit-linear-gradient(left, rgba(225,225,225,0.9) 0%,rgba(240,240,240,0.9) 100%) !important;
   background-clip: padding-box !important;

   -moz-border-radius: 5px !important;    /* Firefox 3.6-, removed in Firefox 13 */
   -webkit-border-radius: 5px !important; /* Safari 4-, Chrome 3- */
   border-radius: 5px !important;         /* Firefox 4+, Safari 5+, Chrome 4+, Opera 10.5+, IE9+ */
}

::-webkit-scrollbar-button
{
   height: 0 !important;
   width: 0 !important;
}

::-webkit-scrollbar-track
{
   background-color: rgba(32, 90, 112, 0.3);

   /*background: rgba(0, 0, 0, 0.1) !important;*/
   -moz-border-radius: 5px !important;    /* Firefox 3.6-, removed in Firefox 13 */
   -webkit-border-radius: 5px !important; /* Safari 4-, Chrome 3- */
   border-radius: 5px !important;         /* Firefox 4+, Safari 5+, Chrome 4+, Opera 10.5+, IE9+ */
}

::-webkit-scrollbar-corner
{
   background: transparent !important;
}

   </style>

</head>

<body>

<div class="graph"></div>

<div class="control-button control-zoom">
   <button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect mdl-button--colored" data-action="zoom_in">
      <i class="material-icons">add</i>
   </button>
   <button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect mdl-button--colored" data-action="zoom_out">
      <i class="material-icons">remove</i>
   </button>
   <button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect mdl-button--colored" data-action="zoom_all_out">
      <i class="material-icons">all_out</i>
   </button>
</div>

<div class="control-level">
   <input class="mdl-slider mdl-js-slider" type="range" min="0" max="8" value="8" step="1" tabindex="0">
   <label class="mdl-textfield__label" style="padding-left: 5px; margin-top: -8px;">8</label>
   <i class="material-icons" style="float: right; margin-top: -24px;">filter_list</i>
</div>

<div class="control-toggles control-deps">
   <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for="dep1">
      <input class="mdl-radio__button" id="dep1" name="dep" type="radio" value="main">
      <span class="mdl-radio__label">Main</span>
   </label>
   <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" style="margin-left: 10px" for="dep2">
      <input class="mdl-radio__button" id="dep2" name="dep" type="radio" value="dev">
      <span class="mdl-radio__label">Dev</span>
   </label>
   <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" style="margin-left: 10px" for="dep3">
      <input checked class="mdl-radio__button" id="dep3" name="dep" type="radio" value="all">
      <span class="mdl-radio__label">All</span>
   </label>
</div>

<div class="control-toggles control-links">
   <label for="chkbox1" class="mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect">
      <input type="checkbox" id="chkbox1" class="mdl-checkbox__input">
      <span class="mdl-checkbox__label">Reverse Links</span>
   </label>
</div>

<div class="control-button control-menu">
   <button id="control-menu" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect">
      <i class="material-icons">more_vert</i>
   </button>

   <ul class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="control-menu">
      <li class="mdl-menu__item mdl-menu__item--full-bleed-divider" data-action="toggleFreezeAllNodes">Freeze nodes</li>
      <li class="mdl-menu__item mdl-menu__item--full-bleed-divider flex-center-left" data-action="showFullNames"><i class="material-icons material-icon-blue">check_box_outline_blank</i>Show aliased full names</li>
      <li class="mdl-menu__item mdl-menu__item--full-bleed-divider flex-center-left" data-action="showTableView"><i class="material-icons material-icon-blue">check_box_outline_blank</i>Show table view</li>
      <li class="mdl-menu__item flex-center-left" data-action="maxDepthSticky"><i class="material-icons material-icon-blue">check_box</i>Max depth sticky</li>
   </ul>
</div>

<div class="control-table hidden">
   <div class="control-table-inner">
   <table class="mdl-data-table mdl-js-data-table mdl-shadow--2dp tablesorter" id="nodeTable">
      <thead>
      <tr>
         <th class="mdl-data-table__cell--non-numeric">Package</th>
         <th class="mdl-data-table__cell--non-numeric">Type</th>
         <th class="mdl-data-table__cell--non-numeric">Version</th>
         <th class="mdl-data-table__cell--non-numeric"><i class="material-icons" style="font-size:14px;">filter_list</i></th>
      </tr>
      </thead>
      <tbody>
      </tbody>
   </table>
   </div>
</div>

<div id="contextpopup">
   <button id="context-menu" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect hidden">
      <i class="material-icons">more_vert</i>
   </button>

   <ul class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="context-menu">
      <li class="mdl-menu__item mdl-menu__item--full-bleed-divider" data-action="openSCMLink">Open on ...</li>
      <li disabled class="mdl-menu__item">Fullname: ...</li>
      <li disabled class="mdl-menu__item">Version: ...</li>
   </ul>
</div>

<script defer src="https://code.getmdl.io/1.1.3/material.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>

<script>
   var getPackageDataAll = function() { return {"maxLevel":8,"directed":true,"multigraph":false,"graph":[],"nodes":[{"id":"npm-babel-core-5-8-38","minLevel":0,"packageScope":"all","packageData":{"type":"npm","name":"babel","fullName":"babel-core","fullPackage":"npm:babel-core@5.8.38","version":"5.8.38","isAliased":true,"link":"https://www.npmjs.com/package/babel-core"},"fixed":false,"index":0},{"id":"npm-babel-runtime-5-8-38","minLevel":0,"packageScope":"all","packageData":{"type":"npm","name":"babel-runtime","fullName":"babel-runtime","fullPackage":"npm:babel-runtime@5.8.38","version":"5.8.38","isAliased":false,"link":"https://www.npmjs.com/package/babel-runtime"},"fixed":false,"index":1},{"id":"github-typhonjs-backbone-backbone-es6-master","minLevel":0,"packageScope":"all","packageData":{"type":"github","name":"backbone-es6","fullName":"backbone-es6","fullPackage":"github:typhonjs-backbone/backbone-es6@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/backbone-es6","owner":"typhonjs-backbone"},"fixed":false,"index":2},{"id":"npm-core-js-1-2-6","minLevel":0,"packageScope":"all","packageData":{"type":"npm","name":"core-js","fullName":"core-js","fullPackage":"npm:core-js@1.2.6","version":"1.2.6","isAliased":false,"link":"https://www.npmjs.com/package/core-js"},"fixed":false,"index":3},{"id":"npm-jquery-2-2-3","minLevel":0,"packageScope":"all","packageData":{"type":"npm","name":"jquery","fullName":"jquery","fullPackage":"npm:jquery@2.2.3","version":"2.2.3","isAliased":false,"link":"https://www.npmjs.com/package/jquery"},"fixed":false,"index":4},{"id":"npm-parse-1-8-4","minLevel":0,"packageScope":"all","packageData":{"type":"npm","name":"parse","fullName":"parse","fullPackage":"npm:parse@1.8.4","version":"1.8.4","isAliased":false,"link":"https://www.npmjs.com/package/parse"},"fixed":false,"index":5},{"id":"github-typhonjs-backbone-typhonjs-core-backbone-common-master","minLevel":0,"packageScope":"all","packageData":{"type":"github","name":"typhonjs-core-backbone-common","fullName":"typhonjs-core-backbone-common","fullPackage":"github:typhonjs-backbone/typhonjs-core-backbone-common@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/typhonjs-core-backbone-common","owner":"typhonjs-backbone"},"fixed":false,"index":6},{"id":"github-typhonjs-backbone-typhonjs-core-backbone-events-master","minLevel":0,"packageScope":"all","packageData":{"type":"github","name":"typhonjs-core-backbone-events","fullName":"typhonjs-core-backbone-events","fullPackage":"github:typhonjs-backbone/typhonjs-core-backbone-events@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/typhonjs-core-backbone-events","owner":"typhonjs-backbone"},"fixed":false,"index":7},{"id":"github-typhonjs-backbone-typhonjs-core-backbone-query-master","minLevel":0,"packageScope":"all","packageData":{"type":"github","name":"typhonjs-core-backbone-query","fullName":"typhonjs-core-backbone-query","fullPackage":"github:typhonjs-backbone/typhonjs-core-backbone-query@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/typhonjs-core-backbone-query","owner":"typhonjs-backbone"},"fixed":false,"index":8},{"id":"github-typhonjs-common-typhonjs-core-utils-master","minLevel":0,"packageScope":"all","packageData":{"type":"github","name":"typhonjs-core-utils","fullName":"typhonjs-core-utils","fullPackage":"github:typhonjs-common/typhonjs-core-utils@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-common/typhonjs-core-utils","owner":"typhonjs-common"},"fixed":false,"index":9},{"id":"npm-underscore-1-8-3","minLevel":0,"packageScope":"all","packageData":{"type":"npm","name":"underscore","fullName":"underscore","fullPackage":"npm:underscore@1.8.3","version":"1.8.3","isAliased":false,"link":"https://www.npmjs.com/package/underscore"},"fixed":false,"index":10},{"id":"github-jspm-nodelibs-process-0-1-2","minLevel":1,"packageScope":"all","packageData":{"type":"github","name":"process","fullName":"nodelibs-process","fullPackage":"github:jspm/nodelibs-process@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/jspm/nodelibs-process","owner":"jspm"},"fixed":false,"index":11},{"id":"github-jspm-nodelibs-fs-0-1-2","minLevel":1,"packageScope":"all","packageData":{"type":"github","name":"fs","fullName":"nodelibs-fs","fullPackage":"github:jspm/nodelibs-fs@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/jspm/nodelibs-fs","owner":"jspm"},"fixed":false,"index":12},{"id":"github-jspm-nodelibs-path-0-1-0","minLevel":1,"packageScope":"all","packageData":{"type":"github","name":"path","fullName":"nodelibs-path","fullPackage":"github:jspm/nodelibs-path@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-path","owner":"jspm"},"fixed":false,"index":13},{"id":"github-systemjs-plugin-json-0-1-2","minLevel":1,"packageScope":"all","packageData":{"type":"github","name":"systemjs-json","fullName":"plugin-json","fullPackage":"github:systemjs/plugin-json@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/systemjs/plugin-json","owner":"systemjs"},"fixed":false,"index":14},{"id":"github-jspm-nodelibs-events-0-1-1","minLevel":1,"packageScope":"all","packageData":{"type":"github","name":"events","fullName":"nodelibs-events","fullPackage":"github:jspm/nodelibs-events@0.1.1","version":"0.1.1","isAliased":true,"link":"https://github.com/jspm/nodelibs-events","owner":"jspm"},"fixed":false,"index":15},{"id":"npm-process-0-11-3","minLevel":2,"packageScope":"all","packageData":{"type":"npm","name":"process","fullName":"process","fullPackage":"npm:process@0.11.3","version":"0.11.3","isAliased":false,"link":"https://www.npmjs.com/package/process"},"fixed":false,"index":16},{"id":"npm-path-browserify-0-0-0","minLevel":2,"packageScope":"all","packageData":{"type":"npm","name":"path-browserify","fullName":"path-browserify","fullPackage":"npm:path-browserify@0.0.0","version":"0.0.0","isAliased":false,"link":"https://www.npmjs.com/package/path-browserify"},"fixed":false,"index":17},{"id":"npm-events-1-0-2","minLevel":2,"packageScope":"all","packageData":{"type":"npm","name":"events","fullName":"events","fullPackage":"npm:events@1.0.2","version":"1.0.2","isAliased":false,"link":"https://www.npmjs.com/package/events"},"fixed":false,"index":18},{"id":"github-jspm-nodelibs-assert-0-1-0","minLevel":3,"packageScope":"all","packageData":{"type":"github","name":"assert","fullName":"nodelibs-assert","fullPackage":"github:jspm/nodelibs-assert@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-assert","owner":"jspm"},"fixed":false,"index":19},{"id":"npm-assert-1-3-0","minLevel":4,"packageScope":"all","packageData":{"type":"npm","name":"assert","fullName":"assert","fullPackage":"npm:assert@1.3.0","version":"1.3.0","isAliased":false,"link":"https://www.npmjs.com/package/assert"},"fixed":false,"index":20},{"id":"npm-util-0-10-3","minLevel":5,"packageScope":"all","packageData":{"type":"npm","name":"util","fullName":"util","fullPackage":"npm:util@0.10.3","version":"0.10.3","isAliased":false,"link":"https://www.npmjs.com/package/util"},"fixed":false,"index":21},{"id":"npm-inherits-2-0-1","minLevel":6,"packageScope":"all","packageData":{"type":"npm","name":"inherits","fullName":"inherits","fullPackage":"npm:inherits@2.0.1","version":"2.0.1","isAliased":false,"link":"https://www.npmjs.com/package/inherits"},"fixed":false,"index":22},{"id":"github-jspm-nodelibs-util-0-1-0","minLevel":7,"packageScope":"all","packageData":{"type":"github","name":"util","fullName":"nodelibs-util","fullPackage":"github:jspm/nodelibs-util@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-util","owner":"jspm"},"fixed":false,"index":23}],"links":[{"source":1,"target":11,"minLevel":1},{"source":2,"target":7,"minLevel":1},{"source":2,"target":10,"minLevel":1},{"source":3,"target":12,"minLevel":1},{"source":3,"target":13,"minLevel":1},{"source":3,"target":11,"minLevel":1},{"source":3,"target":14,"minLevel":1},{"source":5,"target":1,"minLevel":1},{"source":5,"target":15,"minLevel":1},{"source":5,"target":11,"minLevel":1},{"source":6,"target":9,"minLevel":1},{"source":6,"target":10,"minLevel":1},{"source":7,"target":10,"minLevel":1},{"source":8,"target":10,"minLevel":1},{"source":11,"target":16,"minLevel":2},{"source":13,"target":17,"minLevel":2},{"source":15,"target":18,"minLevel":2},{"source":16,"target":19,"minLevel":3},{"source":17,"target":11,"minLevel":3},{"source":19,"target":20,"minLevel":4},{"source":20,"target":21,"minLevel":5},{"source":21,"target":22,"minLevel":6},{"source":21,"target":11,"minLevel":6},{"source":22,"target":23,"minLevel":7},{"source":23,"target":21,"minLevel":8}]}; };
   var getPackageDataDev = function() { return {"maxLevel":8,"directed":true,"multigraph":false,"graph":[],"nodes":[{"id":"npm-babel-core-5-8-38","minLevel":0,"packageScope":"dev","packageData":{"type":"npm","name":"babel","fullName":"babel-core","fullPackage":"npm:babel-core@5.8.38","version":"5.8.38","isAliased":true,"link":"https://www.npmjs.com/package/babel-core"},"fixed":false,"index":0},{"id":"npm-babel-runtime-5-8-38","minLevel":0,"packageScope":"dev","packageData":{"type":"npm","name":"babel-runtime","fullName":"babel-runtime","fullPackage":"npm:babel-runtime@5.8.38","version":"5.8.38","isAliased":false,"link":"https://www.npmjs.com/package/babel-runtime"},"fixed":false,"index":1},{"id":"npm-core-js-1-2-6","minLevel":0,"packageScope":"dev","packageData":{"type":"npm","name":"core-js","fullName":"core-js","fullPackage":"npm:core-js@1.2.6","version":"1.2.6","isAliased":false,"link":"https://www.npmjs.com/package/core-js"},"fixed":false,"index":2},{"id":"npm-jquery-2-2-3","minLevel":0,"packageScope":"dev","packageData":{"type":"npm","name":"jquery","fullName":"jquery","fullPackage":"npm:jquery@2.2.3","version":"2.2.3","isAliased":false,"link":"https://www.npmjs.com/package/jquery"},"fixed":false,"index":3},{"id":"github-jspm-nodelibs-process-0-1-2","minLevel":1,"packageScope":"dev","packageData":{"type":"github","name":"process","fullName":"nodelibs-process","fullPackage":"github:jspm/nodelibs-process@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/jspm/nodelibs-process","owner":"jspm"},"fixed":false,"index":4},{"id":"github-jspm-nodelibs-fs-0-1-2","minLevel":1,"packageScope":"dev","packageData":{"type":"github","name":"fs","fullName":"nodelibs-fs","fullPackage":"github:jspm/nodelibs-fs@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/jspm/nodelibs-fs","owner":"jspm"},"fixed":false,"index":5},{"id":"github-jspm-nodelibs-path-0-1-0","minLevel":1,"packageScope":"dev","packageData":{"type":"github","name":"path","fullName":"nodelibs-path","fullPackage":"github:jspm/nodelibs-path@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-path","owner":"jspm"},"fixed":false,"index":6},{"id":"github-systemjs-plugin-json-0-1-2","minLevel":1,"packageScope":"dev","packageData":{"type":"github","name":"systemjs-json","fullName":"plugin-json","fullPackage":"github:systemjs/plugin-json@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/systemjs/plugin-json","owner":"systemjs"},"fixed":false,"index":7},{"id":"npm-process-0-11-3","minLevel":2,"packageScope":"dev","packageData":{"type":"npm","name":"process","fullName":"process","fullPackage":"npm:process@0.11.3","version":"0.11.3","isAliased":false,"link":"https://www.npmjs.com/package/process"},"fixed":false,"index":8},{"id":"npm-path-browserify-0-0-0","minLevel":2,"packageScope":"dev","packageData":{"type":"npm","name":"path-browserify","fullName":"path-browserify","fullPackage":"npm:path-browserify@0.0.0","version":"0.0.0","isAliased":false,"link":"https://www.npmjs.com/package/path-browserify"},"fixed":false,"index":9},{"id":"github-jspm-nodelibs-assert-0-1-0","minLevel":3,"packageScope":"dev","packageData":{"type":"github","name":"assert","fullName":"nodelibs-assert","fullPackage":"github:jspm/nodelibs-assert@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-assert","owner":"jspm"},"fixed":false,"index":10},{"id":"npm-assert-1-3-0","minLevel":4,"packageScope":"dev","packageData":{"type":"npm","name":"assert","fullName":"assert","fullPackage":"npm:assert@1.3.0","version":"1.3.0","isAliased":false,"link":"https://www.npmjs.com/package/assert"},"fixed":false,"index":11},{"id":"npm-util-0-10-3","minLevel":5,"packageScope":"dev","packageData":{"type":"npm","name":"util","fullName":"util","fullPackage":"npm:util@0.10.3","version":"0.10.3","isAliased":false,"link":"https://www.npmjs.com/package/util"},"fixed":false,"index":12},{"id":"npm-inherits-2-0-1","minLevel":6,"packageScope":"dev","packageData":{"type":"npm","name":"inherits","fullName":"inherits","fullPackage":"npm:inherits@2.0.1","version":"2.0.1","isAliased":false,"link":"https://www.npmjs.com/package/inherits"},"fixed":false,"index":13},{"id":"github-jspm-nodelibs-util-0-1-0","minLevel":7,"packageScope":"dev","packageData":{"type":"github","name":"util","fullName":"nodelibs-util","fullPackage":"github:jspm/nodelibs-util@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-util","owner":"jspm"},"fixed":false,"index":14}],"links":[{"source":1,"target":4,"minLevel":1},{"source":2,"target":5,"minLevel":1},{"source":2,"target":6,"minLevel":1},{"source":2,"target":4,"minLevel":1},{"source":2,"target":7,"minLevel":1},{"source":4,"target":8,"minLevel":2},{"source":6,"target":9,"minLevel":2},{"source":8,"target":10,"minLevel":3},{"source":9,"target":4,"minLevel":3},{"source":10,"target":11,"minLevel":4},{"source":11,"target":12,"minLevel":5},{"source":12,"target":13,"minLevel":6},{"source":12,"target":4,"minLevel":6},{"source":13,"target":14,"minLevel":7},{"source":14,"target":12,"minLevel":8}]}; };
   var getPackageDataMain = function() { return {"maxLevel":8,"directed":true,"multigraph":false,"graph":[],"nodes":[{"id":"github-typhonjs-backbone-backbone-es6-master","minLevel":0,"packageScope":"main","packageData":{"type":"github","name":"backbone-es6","fullName":"backbone-es6","fullPackage":"github:typhonjs-backbone/backbone-es6@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/backbone-es6","owner":"typhonjs-backbone"},"fixed":false,"index":0},{"id":"npm-parse-1-8-4","minLevel":0,"packageScope":"main","packageData":{"type":"npm","name":"parse","fullName":"parse","fullPackage":"npm:parse@1.8.4","version":"1.8.4","isAliased":false,"link":"https://www.npmjs.com/package/parse"},"fixed":false,"index":1},{"id":"github-typhonjs-backbone-typhonjs-core-backbone-common-master","minLevel":0,"packageScope":"main","packageData":{"type":"github","name":"typhonjs-core-backbone-common","fullName":"typhonjs-core-backbone-common","fullPackage":"github:typhonjs-backbone/typhonjs-core-backbone-common@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/typhonjs-core-backbone-common","owner":"typhonjs-backbone"},"fixed":false,"index":2},{"id":"github-typhonjs-backbone-typhonjs-core-backbone-events-master","minLevel":0,"packageScope":"main","packageData":{"type":"github","name":"typhonjs-core-backbone-events","fullName":"typhonjs-core-backbone-events","fullPackage":"github:typhonjs-backbone/typhonjs-core-backbone-events@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/typhonjs-core-backbone-events","owner":"typhonjs-backbone"},"fixed":false,"index":3},{"id":"github-typhonjs-backbone-typhonjs-core-backbone-query-master","minLevel":0,"packageScope":"main","packageData":{"type":"github","name":"typhonjs-core-backbone-query","fullName":"typhonjs-core-backbone-query","fullPackage":"github:typhonjs-backbone/typhonjs-core-backbone-query@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-backbone/typhonjs-core-backbone-query","owner":"typhonjs-backbone"},"fixed":false,"index":4},{"id":"github-typhonjs-common-typhonjs-core-utils-master","minLevel":0,"packageScope":"main","packageData":{"type":"github","name":"typhonjs-core-utils","fullName":"typhonjs-core-utils","fullPackage":"github:typhonjs-common/typhonjs-core-utils@master","version":"master","isAliased":false,"link":"https://github.com/typhonjs-common/typhonjs-core-utils","owner":"typhonjs-common"},"fixed":false,"index":5},{"id":"npm-underscore-1-8-3","minLevel":0,"packageScope":"main","packageData":{"type":"npm","name":"underscore","fullName":"underscore","fullPackage":"npm:underscore@1.8.3","version":"1.8.3","isAliased":false,"link":"https://www.npmjs.com/package/underscore"},"fixed":false,"index":6},{"id":"npm-babel-runtime-5-8-38","minLevel":1,"packageScope":"main","packageData":{"type":"npm","name":"babel-runtime","fullName":"babel-runtime","fullPackage":"npm:babel-runtime@5.8.38","version":"5.8.38","isAliased":false,"link":"https://www.npmjs.com/package/babel-runtime"},"fixed":false,"index":7},{"id":"github-jspm-nodelibs-events-0-1-1","minLevel":1,"packageScope":"main","packageData":{"type":"github","name":"events","fullName":"nodelibs-events","fullPackage":"github:jspm/nodelibs-events@0.1.1","version":"0.1.1","isAliased":true,"link":"https://github.com/jspm/nodelibs-events","owner":"jspm"},"fixed":false,"index":8},{"id":"github-jspm-nodelibs-process-0-1-2","minLevel":1,"packageScope":"main","packageData":{"type":"github","name":"process","fullName":"nodelibs-process","fullPackage":"github:jspm/nodelibs-process@0.1.2","version":"0.1.2","isAliased":true,"link":"https://github.com/jspm/nodelibs-process","owner":"jspm"},"fixed":false,"index":9},{"id":"npm-events-1-0-2","minLevel":2,"packageScope":"main","packageData":{"type":"npm","name":"events","fullName":"events","fullPackage":"npm:events@1.0.2","version":"1.0.2","isAliased":false,"link":"https://www.npmjs.com/package/events"},"fixed":false,"index":10},{"id":"npm-process-0-11-3","minLevel":2,"packageScope":"main","packageData":{"type":"npm","name":"process","fullName":"process","fullPackage":"npm:process@0.11.3","version":"0.11.3","isAliased":false,"link":"https://www.npmjs.com/package/process"},"fixed":false,"index":11},{"id":"github-jspm-nodelibs-assert-0-1-0","minLevel":3,"packageScope":"main","packageData":{"type":"github","name":"assert","fullName":"nodelibs-assert","fullPackage":"github:jspm/nodelibs-assert@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-assert","owner":"jspm"},"fixed":false,"index":12},{"id":"npm-assert-1-3-0","minLevel":4,"packageScope":"main","packageData":{"type":"npm","name":"assert","fullName":"assert","fullPackage":"npm:assert@1.3.0","version":"1.3.0","isAliased":false,"link":"https://www.npmjs.com/package/assert"},"fixed":false,"index":13},{"id":"npm-util-0-10-3","minLevel":5,"packageScope":"main","packageData":{"type":"npm","name":"util","fullName":"util","fullPackage":"npm:util@0.10.3","version":"0.10.3","isAliased":false,"link":"https://www.npmjs.com/package/util"},"fixed":false,"index":14},{"id":"npm-inherits-2-0-1","minLevel":6,"packageScope":"main","packageData":{"type":"npm","name":"inherits","fullName":"inherits","fullPackage":"npm:inherits@2.0.1","version":"2.0.1","isAliased":false,"link":"https://www.npmjs.com/package/inherits"},"fixed":false,"index":15},{"id":"github-jspm-nodelibs-util-0-1-0","minLevel":7,"packageScope":"main","packageData":{"type":"github","name":"util","fullName":"nodelibs-util","fullPackage":"github:jspm/nodelibs-util@0.1.0","version":"0.1.0","isAliased":true,"link":"https://github.com/jspm/nodelibs-util","owner":"jspm"},"fixed":false,"index":16}],"links":[{"source":0,"target":3,"minLevel":1},{"source":0,"target":6,"minLevel":1},{"source":1,"target":7,"minLevel":1},{"source":1,"target":8,"minLevel":1},{"source":1,"target":9,"minLevel":1},{"source":2,"target":5,"minLevel":1},{"source":2,"target":6,"minLevel":1},{"source":3,"target":6,"minLevel":1},{"source":4,"target":6,"minLevel":1},{"source":7,"target":9,"minLevel":2},{"source":8,"target":10,"minLevel":2},{"source":9,"target":11,"minLevel":2},{"source":11,"target":12,"minLevel":3},{"source":12,"target":13,"minLevel":4},{"source":13,"target":14,"minLevel":5},{"source":14,"target":15,"minLevel":6},{"source":14,"target":9,"minLevel":6},{"source":15,"target":16,"minLevel":7},{"source":16,"target":14,"minLevel":8}]}; };

   /* eslint-disable */

/* ! TableSorter (FORK) v2.25.7 *//*
 * Client-side table sorting with ease!
 * @requires jQuery v1.2.6+
 *
 * Copyright (c) 2007 Christian Bach
 * fork maintained by Rob Garrison
 *
 * Examples and docs at: http://tablesorter.com
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * @type jQuery
 * @name tablesorter (FORK)
 * @cat Plugins/Tablesorter
 * @author Christian Bach - christian.bach@polyester.se
 * @contributor Rob Garrison - https://github.com/Mottie/tablesorter
 */
/* browser:true, jquery:true, unused:false, expr: true */
(function($) {
   'use strict';

   var ts = $.tablesorter = {

      version : '2.25.7',

      parsers : [],
      widgets : [],
      defaults : {

         // *** appearance
         theme            : 'default',  // adds tablesorter-{theme} to the table for styling
         widthFixed       : false,      // adds colgroup to fix widths of columns
         showProcessing   : false,      // show an indeterminate timer icon in the header when the table is sorted or filtered.

         headerTemplate   : '{content}',// header layout template (HTML ok); {content} = innerHTML, {icon} = <i/> // class from cssIcon
         onRenderTemplate : null,       // function( index, template ){ return template; }, // template is a string
         onRenderHeader   : null,       // function( index ){}, // nothing to return

         // *** functionality
         cancelSelection  : true,       // prevent text selection in the header
         tabIndex         : true,       // add tabindex to header for keyboard accessibility
         dateFormat       : 'mmddyyyy', // other options: 'ddmmyyy' or 'yyyymmdd'
         sortMultiSortKey : 'shiftKey', // key used to select additional columns
         sortResetKey     : 'ctrlKey',  // key used to remove sorting on a column
         usNumberFormat   : true,       // false for German '1.234.567,89' or French '1 234 567,89'
         delayInit        : false,      // if false, the parsed table contents will not update until the first sort
         serverSideSorting: false,      // if true, server-side sorting should be performed because client-side sorting will be disabled, but the ui and events will still be used.
         resort           : true,       // default setting to trigger a resort after an 'update', 'addRows', 'updateCell', etc has completed

         // *** sort options
         headers          : {},         // set sorter, string, empty, locked order, sortInitialOrder, filter, etc.
         ignoreCase       : true,       // ignore case while sorting
         sortForce        : null,       // column(s) first sorted; always applied
         sortList         : [],         // Initial sort order; applied initially; updated when manually sorted
         sortAppend       : null,       // column(s) sorted last; always applied
         sortStable       : false,      // when sorting two rows with exactly the same content, the original sort order is maintained

         sortInitialOrder : 'asc',      // sort direction on first click
         sortLocaleCompare: false,      // replace equivalent character (accented characters)
         sortReset        : false,      // third click on the header will reset column to default - unsorted
         sortRestart      : false,      // restart sort to 'sortInitialOrder' when clicking on previously unsorted columns

         emptyTo          : 'bottom',   // sort empty cell to bottom, top, none, zero, emptyMax, emptyMin
         stringTo         : 'max',      // sort strings in numerical column as max, min, top, bottom, zero
         duplicateSpan    : true,       // colspan cells in the tbody will have duplicated content in the cache for each spanned column
         textExtraction   : 'basic',    // text extraction method/function - function( node, table, cellIndex ){}
         textAttribute    : 'data-text',// data-attribute that contains alternate cell text (used in default textExtraction function)
         textSorter       : null,       // choose overall or specific column sorter function( a, b, direction, table, columnIndex ) [alt: ts.sortText]
         numberSorter     : null,       // choose overall numeric sorter function( a, b, direction, maxColumnValue )

         // *** widget options
         widgets: [],                   // method to add widgets, e.g. widgets: ['zebra']
         widgetOptions    : {
            zebra : [ 'even', 'odd' ]    // zebra widget alternating row class names
         },
         initWidgets      : true,       // apply widgets on tablesorter initialization
         widgetClass      : 'widget-{name}', // table class name template to match to include a widget

         // *** callbacks
         initialized      : null,       // function( table ){},

         // *** extra css class names
         tableClass       : '',
         cssAsc           : '',
         cssDesc          : '',
         cssNone          : '',
         cssHeader        : '',
         cssHeaderRow     : '',
         cssProcessing    : '', // processing icon applied to header during sort/filter

         cssChildRow      : 'tablesorter-childRow', // class name indiciating that a row is to be attached to the its parent
         cssInfoBlock     : 'tablesorter-infoOnly', // don't sort tbody with this class name (only one class name allowed here!)
         cssNoSort        : 'tablesorter-noSort',      // class name added to element inside header; clicking on it won't cause a sort
         cssIgnoreRow     : 'tablesorter-ignoreRow',   // header row to ignore; cells within this row will not be added to c.$headers

         cssIcon          : 'tablesorter-icon', // if this class does not exist, the {icon} will not be added from the headerTemplate
         cssIconNone      : '', // class name added to the icon when there is no column sort
         cssIconAsc       : '', // class name added to the icon when the column has an ascending sort
         cssIconDesc      : '', // class name added to the icon when the column has a descending sort

         // *** events
         pointerClick     : 'click',
         pointerDown      : 'mousedown',
         pointerUp        : 'mouseup',

         // *** selectors
         selectorHeaders  : '> thead th, > thead td',
         selectorSort     : 'th, td',   // jQuery selector of content within selectorHeaders that is clickable to trigger a sort
         selectorRemove   : '.remove-me',

         // *** advanced
         debug            : false,

         // *** Internal variables
         headerList: [],
         empties: {},
         strings: {},
         parsers: []

         // removed: widgetZebra: { css: ['even', 'odd'] }

      },

      // internal css classes - these will ALWAYS be added to
      // the table and MUST only contain one class name - fixes #381
      css : {
         table      : 'tablesorter',
         cssHasChild: 'tablesorter-hasChildRow',
         childRow   : 'tablesorter-childRow',
         colgroup   : 'tablesorter-colgroup',
         header     : 'tablesorter-header',
         headerRow  : 'tablesorter-headerRow',
         headerIn   : 'tablesorter-header-inner',
         icon       : 'tablesorter-icon',
         processing : 'tablesorter-processing',
         sortAsc    : 'tablesorter-headerAsc',
         sortDesc   : 'tablesorter-headerDesc',
         sortNone   : 'tablesorter-headerUnSorted'
      },

      // labels applied to sortable headers for accessibility (aria) support
      language : {
         sortAsc      : 'Ascending sort applied, ',
         sortDesc     : 'Descending sort applied, ',
         sortNone     : 'No sort applied, ',
         sortDisabled : 'sorting is disabled',
         nextAsc      : 'activate to apply an ascending sort',
         nextDesc     : 'activate to apply a descending sort',
         nextNone     : 'activate to remove the sort'
      },

      regex : {
         templateContent : /\{content\}/g,
         templateIcon    : /\{icon\}/g,
         templateName    : /\{name\}/i,
         spaces          : /\s+/g,
         nonWord         : /\W/g,
         formElements    : /(input|select|button|textarea)/i,

         // *** sort functions ***
         // regex used in natural sort
         // chunk/tokenize numbers & letters
         chunk  : /(^([+\-]?(?:\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
         // replace chunks @ ends
         chunks : /(^\\0|\\0$)/,
         hex    : /^0x[0-9a-f]+$/i,

         // *** formatFloat ***
         comma                : /,/g,
         digitNonUS           : /[\s|\.]/g,
         digitNegativeTest    : /^\s*\([.\d]+\)/,
         digitNegativeReplace : /^\s*\(([.\d]+)\)/,

         // *** isDigit ***
         digitTest    : /^[\-+(]?\d+[)]?$/,
         digitReplace : /[,.'"\s]/g

      },

      // digit sort, text location
      string : {
         max      : 1,
         min      : -1,
         emptymin : 1,
         emptymax : -1,
         zero     : 0,
         none     : 0,
         'null'   : 0,
         top      : true,
         bottom   : false
      },

      keyCodes : {
         enter : 13
      },

      // placeholder date parser data (globalize)
      dates : {},

      // These methods can be applied on table.config instance
      instanceMethods : {},

      /*
       ▄█████ ██████ ██████ ██  ██ █████▄
       ▀█▄    ██▄▄     ██   ██  ██ ██▄▄██
       ▀█▄ ██▀▀     ██   ██  ██ ██▀▀▀
       █████▀ ██████   ██   ▀████▀ ██
       */

      setup : function( table, c ) {
         // if no thead or tbody, or tablesorter is already present, quit
         if ( !table || !table.tHead || table.tBodies.length === 0 || table.hasInitialized === true ) {
            if ( c.debug ) {
               if ( table.hasInitialized ) {
                  console.warn( 'Stopping initialization. Tablesorter has already been initialized' );
               } else {
                  console.error( 'Stopping initialization! No table, thead or tbody', table );
               }
            }
            return;
         }

         var tmp = '',
          $table = $( table ),
          meta = $.metadata;
         // initialization flag
         table.hasInitialized = false;
         // table is being processed flag
         table.isProcessing = true;
         // make sure to store the config object
         table.config = c;
         // save the settings where they read
         $.data( table, 'tablesorter', c );
         if ( c.debug ) {
            console[ console.group ? 'group' : 'log' ]( 'Initializing tablesorter' );
            $.data( table, 'startoveralltimer', new Date() );
         }

         // removing this in version 3 (only supports jQuery 1.7+)
         c.supportsDataObject = ( function( version ) {
            version[ 0 ] = parseInt( version[ 0 ], 10 );
            return ( version[ 0 ] > 1 ) || ( version[ 0 ] === 1 && parseInt( version[ 1 ], 10 ) >= 4 );
         })( $.fn.jquery.split( '.' ) );
         // ensure case insensitivity
         c.emptyTo = c.emptyTo.toLowerCase();
         c.stringTo = c.stringTo.toLowerCase();
         c.last = { sortList : [], clickedIndex : -1 };
         // add table theme class only if there isn't already one there
         if ( !/tablesorter\-/.test( $table.attr( 'class' ) ) ) {
            tmp = ( c.theme !== '' ? ' tablesorter-' + c.theme : '' );
         }
         c.table = table;
         c.$table = $table
          .addClass( ts.css.table + ' ' + c.tableClass + tmp )
          .attr( 'role', 'grid' );
         c.$headers = $table.find( c.selectorHeaders );

         // give the table a unique id, which will be used in namespace binding
         if ( !c.namespace ) {
            c.namespace = '.tablesorter' + Math.random().toString( 16 ).slice( 2 );
         } else {
            // make sure namespace starts with a period & doesn't have weird characters
            c.namespace = '.' + c.namespace.replace( ts.regex.nonWord, '' );
         }

         c.$table.children().children( 'tr' ).attr( 'role', 'row' );
         c.$tbodies = $table.children( 'tbody:not(.' + c.cssInfoBlock + ')' ).attr({
            'aria-live' : 'polite',
            'aria-relevant' : 'all'
         });
         if ( c.$table.children( 'caption' ).length ) {
            tmp = c.$table.children( 'caption' )[ 0 ];
            if ( !tmp.id ) { tmp.id = c.namespace.slice( 1 ) + 'caption'; }
            c.$table.attr( 'aria-labelledby', tmp.id );
         }
         c.widgetInit = {}; // keep a list of initialized widgets
         // change textExtraction via data-attribute
         c.textExtraction = c.$table.attr( 'data-text-extraction' ) || c.textExtraction || 'basic';
         // build headers
         ts.buildHeaders( c );
         // fixate columns if the users supplies the fixedWidth option
         // do this after theme has been applied
         ts.fixColumnWidth( table );
         // add widgets from class name
         ts.addWidgetFromClass( table );
         // add widget options before parsing (e.g. grouping widget has parser settings)
         ts.applyWidgetOptions( table );
         // try to auto detect column type, and store in tables config
         ts.setupParsers( c );
         // start total row count at zero
         c.totalRows = 0;
         // build the cache for the tbody cells
         // delayInit will delay building the cache until the user starts a sort
         if ( !c.delayInit ) { ts.buildCache( c ); }
         // bind all header events and methods
         ts.bindEvents( table, c.$headers, true );
         ts.bindMethods( c );
         // get sort list from jQuery data or metadata
         // in jQuery < 1.4, an error occurs when calling $table.data()
         if ( c.supportsDataObject && typeof $table.data().sortlist !== 'undefined' ) {
            c.sortList = $table.data().sortlist;
         } else if ( meta && ( $table.metadata() && $table.metadata().sortlist ) ) {
            c.sortList = $table.metadata().sortlist;
         }
         // apply widget init code
         ts.applyWidget( table, true );
         // if user has supplied a sort list to constructor
         if ( c.sortList.length > 0 ) {
            ts.sortOn( c, c.sortList, {}, !c.initWidgets );
         } else {
            ts.setHeadersCss( c );
            if ( c.initWidgets ) {
               // apply widget format
               ts.applyWidget( table, false );
            }
         }

         // show processesing icon
         if ( c.showProcessing ) {
            $table
             .unbind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace )
             .bind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace, function( e ) {
                clearTimeout( c.timerProcessing );
                ts.isProcessing( table );
                if ( e.type === 'sortBegin' ) {
                   c.timerProcessing = setTimeout( function() {
                      ts.isProcessing( table, true );
                   }, 500 );
                }
             });
         }

         // initialized
         table.hasInitialized = true;
         table.isProcessing = false;
         if ( c.debug ) {
            console.log( 'Overall initialization time: ' + ts.benchmark( $.data( table, 'startoveralltimer' ) ) );
            if ( c.debug && console.groupEnd ) { console.groupEnd(); }
         }
         $table.triggerHandler( 'tablesorter-initialized', table );
         if ( typeof c.initialized === 'function' ) {
            c.initialized( table );
         }
      },

      bindMethods : function( c ) {
         var $table = c.$table,
          namespace = c.namespace,
          events = ( 'sortReset update updateRows updateAll updateHeaders addRows updateCell updateComplete ' +
          'sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup ' +
          'mouseleave ' ).split( ' ' )
           .join( namespace + ' ' );
         // apply easy methods that trigger bound events
         $table
          .unbind( events.replace( ts.regex.spaces, ' ' ) )
          .bind( 'sortReset' + namespace, function( e, callback ) {
             e.stopPropagation();
             // using this.config to ensure functions are getting a non-cached version of the config
             ts.sortReset( this.config, callback );
          })
          .bind( 'updateAll' + namespace, function( e, resort, callback ) {
             e.stopPropagation();
             ts.updateAll( this.config, resort, callback );
          })
          .bind( 'update' + namespace + ' updateRows' + namespace, function( e, resort, callback ) {
             e.stopPropagation();
             ts.update( this.config, resort, callback );
          })
          .bind( 'updateHeaders' + namespace, function( e, callback ) {
             e.stopPropagation();
             ts.updateHeaders( this.config, callback );
          })
          .bind( 'updateCell' + namespace, function( e, cell, resort, callback ) {
             e.stopPropagation();
             ts.updateCell( this.config, cell, resort, callback );
          })
          .bind( 'addRows' + namespace, function( e, $row, resort, callback ) {
             e.stopPropagation();
             ts.addRows( this.config, $row, resort, callback );
          })
          .bind( 'updateComplete' + namespace, function() {
             this.isUpdating = false;
          })
          .bind( 'sorton' + namespace, function( e, list, callback, init ) {
             e.stopPropagation();
             ts.sortOn( this.config, list, callback, init );
          })
          .bind( 'appendCache' + namespace, function( e, callback, init ) {
             e.stopPropagation();
             ts.appendCache( this.config, init );
             if ( $.isFunction( callback ) ) {
                callback( this );
             }
          })
          // $tbodies variable is used by the tbody sorting widget
          .bind( 'updateCache' + namespace, function( e, callback, $tbodies ) {
             e.stopPropagation();
             ts.updateCache( this.config, callback, $tbodies );
          })
          .bind( 'applyWidgetId' + namespace, function( e, id ) {
             e.stopPropagation();
             ts.applyWidgetId( this, id );
          })
          .bind( 'applyWidgets' + namespace, function( e, init ) {
             e.stopPropagation();
             // apply widgets
             ts.applyWidget( this, init );
          })
          .bind( 'refreshWidgets' + namespace, function( e, all, dontapply ) {
             e.stopPropagation();
             ts.refreshWidgets( this, all, dontapply );
          })
          .bind( 'removeWidget' + namespace, function( e, name, refreshing ) {
             e.stopPropagation();
             ts.removeWidget( this, name, refreshing );
          })
          .bind( 'destroy' + namespace, function( e, removeClasses, callback ) {
             e.stopPropagation();
             ts.destroy( this, removeClasses, callback );
          })
          .bind( 'resetToLoadState' + namespace, function( e ) {
             e.stopPropagation();
             // remove all widgets
             ts.removeWidget( this, true, false );
             // restore original settings; this clears out current settings, but does not clear
             // values saved to storage.
             c = $.extend( true, ts.defaults, c.originalSettings );
             this.hasInitialized = false;
             // setup the entire table again
             ts.setup( this, c );
          });
      },

      bindEvents : function( table, $headers, core ) {
         table = $( table )[ 0 ];
         var tmp,
          c = table.config,
          namespace = c.namespace,
          downTarget = null;
         if ( core !== true ) {
            $headers.addClass( namespace.slice( 1 ) + '_extra_headers' );
            tmp = $.fn.closest ? $headers.closest( 'table' )[ 0 ] : $headers.parents( 'table' )[ 0 ];
            if ( tmp && tmp.nodeName === 'TABLE' && tmp !== table ) {
               $( tmp ).addClass( namespace.slice( 1 ) + '_extra_table' );
            }
         }
         tmp = ( c.pointerDown + ' ' + c.pointerUp + ' ' + c.pointerClick + ' sort keyup ' )
          .replace( ts.regex.spaces, ' ' )
          .split( ' ' )
          .join( namespace + ' ' );
         // apply event handling to headers and/or additional headers (stickyheaders, scroller, etc)
         $headers
         // http://stackoverflow.com/questions/5312849/jquery-find-self;
          .find( c.selectorSort )
          .add( $headers.filter( c.selectorSort ) )
          .unbind( tmp )
          .bind( tmp, function( e, external ) {
             var $cell, cell, temp,
              $target = $( e.target ),
             // wrap event type in spaces, so the match doesn't trigger on inner words
              type = ' ' + e.type + ' ';
             // only recognize left clicks
             if ( ( ( e.which || e.button ) !== 1 && !type.match( ' ' + c.pointerClick + ' | sort | keyup ' ) ) ||
                 // allow pressing enter
              ( type === ' keyup ' && e.which !== ts.keyCodes.enter ) ||
                 // allow triggering a click event (e.which is undefined) & ignore physical clicks
              ( type.match( ' ' + c.pointerClick + ' ' ) && typeof e.which !== 'undefined' ) ) {
                return;
             }
             // ignore mouseup if mousedown wasn't on the same target
             if ( type.match( ' ' + c.pointerUp + ' ' ) && downTarget !== e.target && external !== true ) {
                return;
             }
             // set target on mousedown
             if ( type.match( ' ' + c.pointerDown + ' ' ) ) {
                downTarget = e.target;
                // preventDefault needed or jQuery v1.3.2 and older throws an
                // "Uncaught TypeError: handler.apply is not a function" error
                temp = $target.jquery.split( '.' );
                if ( temp[ 0 ] === '1' && temp[ 1 ] < 4 ) { e.preventDefault(); }
                return;
             }
             downTarget = null;
             // prevent sort being triggered on form elements
             if ( ts.regex.formElements.test( e.target.nodeName ) ||
                 // nosort class name, or elements within a nosort container
              $target.hasClass( c.cssNoSort ) || $target.parents( '.' + c.cssNoSort ).length > 0 ||
                 // elements within a button
              $target.parents( 'button' ).length > 0 ) {
                return !c.cancelSelection;
             }
             if ( c.delayInit && ts.isEmptyObject( c.cache ) ) {
                ts.buildCache( c );
             }
             // jQuery v1.2.6 doesn't have closest()
             $cell = $.fn.closest ? $( this ).closest( 'th, td' ) :
              /TH|TD/.test( this.nodeName ) ? $( this ) : $( this ).parents( 'th, td' );
             // reference original table headers and find the same cell
             // don't use $headers or IE8 throws an error - see #987
             temp = $headers.index( $cell );
             c.last.clickedIndex = ( temp < 0 ) ? $cell.attr( 'data-column' ) : temp;
             // use column index if $headers is undefined
             cell = c.$headers[ c.last.clickedIndex ];
             if ( cell && !cell.sortDisabled ) {
                ts.initSort( c, cell, e );
             }
          });
         if ( c.cancelSelection ) {
            // cancel selection
            $headers
             .attr( 'unselectable', 'on' )
             .bind( 'selectstart', false )
             .css({
                'user-select' : 'none',
                'MozUserSelect' : 'none' // not needed for jQuery 1.8+
             });
         }
      },

      buildHeaders : function( c ) {
         var $temp, icon, timer, indx;
         c.headerList = [];
         c.headerContent = [];
         c.sortVars = [];
         if ( c.debug ) {
            timer = new Date();
         }
         // children tr in tfoot - see issue #196 & #547
         // don't pass table.config to computeColumnIndex here - widgets (math) pass it to "quickly" index tbody cells
         c.columns = ts.computeColumnIndex( c.$table.children( 'thead, tfoot' ).children( 'tr' ) );
         // add icon if cssIcon option exists
         icon = c.cssIcon ?
         '<i class="' + ( c.cssIcon === ts.css.icon ? ts.css.icon : c.cssIcon + ' ' + ts.css.icon ) + '"></i>' :
          '';
         // redefine c.$headers here in case of an updateAll that replaces or adds an entire header cell - see #683
         c.$headers = $( $.map( c.$table.find( c.selectorHeaders ), function( elem, index ) {
            var configHeaders, header, column, template, tmp,
             $elem = $( elem );
            // ignore cell (don't add it to c.$headers) if row has ignoreRow class
            if ( $elem.parent().hasClass( c.cssIgnoreRow ) ) { return; }
            // make sure to get header cell & not column indexed cell
            configHeaders = ts.getColumnData( c.table, c.headers, index, true );
            // save original header content
            c.headerContent[ index ] = $elem.html();
            // if headerTemplate is empty, don't reformat the header cell
            if ( c.headerTemplate !== '' && !$elem.find( '.' + ts.css.headerIn ).length ) {
               // set up header template
               template = c.headerTemplate
                .replace( ts.regex.templateContent, $elem.html() )
                .replace( ts.regex.templateIcon, $elem.find( '.' + ts.css.icon ).length ? '' : icon );
               if ( c.onRenderTemplate ) {
                  header = c.onRenderTemplate.apply( $elem, [ index, template ] );
                  // only change t if something is returned
                  if ( header && typeof header === 'string' ) {
                     template = header;
                  }
               }
               $elem.html( '<div class="' + ts.css.headerIn + '">' + template + '</div>' ); // faster than wrapInner
            }
            if ( c.onRenderHeader ) {
               c.onRenderHeader.apply( $elem, [ index, c, c.$table ] );
            }
            column = parseInt( $elem.attr( 'data-column' ), 10 );
            elem.column = column;
            tmp = ts.getData( $elem, configHeaders, 'sortInitialOrder' ) || c.sortInitialOrder;
            // this may get updated numerous times if there are multiple rows
            c.sortVars[ column ] = {
               count : -1, // set to -1 because clicking on the header automatically adds one
               order: ts.getOrder( tmp ) ?
                [ 1, 0, 2 ] : // desc, asc, unsorted
                [ 0, 1, 2 ],  // asc, desc, unsorted
               lockedOrder : false
            };
            tmp = ts.getData( $elem, configHeaders, 'lockedOrder' ) || false;
            if ( typeof tmp !== 'undefined' && tmp !== false ) {
               c.sortVars[ column ].lockedOrder = true;
               c.sortVars[ column ].order = ts.getOrder( tmp ) ? [ 1, 1, 1 ] : [ 0, 0, 0 ];
            }
            // add cell to headerList
            c.headerList[ index ] = elem;
            // add to parent in case there are multiple rows
            $elem
             .addClass( ts.css.header + ' ' + c.cssHeader )
             .parent()
             .addClass( ts.css.headerRow + ' ' + c.cssHeaderRow )
             .attr( 'role', 'row' );
            // allow keyboard cursor to focus on element
            if ( c.tabIndex ) {
               $elem.attr( 'tabindex', 0 );
            }
            return elem;
         }) );
         // cache headers per column
         c.$headerIndexed = [];
         for ( indx = 0; indx < c.columns; indx++ ) {
            // colspan in header making a column undefined
            if ( ts.isEmptyObject( c.sortVars[ indx ] ) ) {
               c.sortVars[ indx ] = {};
            }
            $temp = c.$headers.filter( '[data-column="' + indx + '"]' );
            // target sortable column cells, unless there are none, then use non-sortable cells
            // .last() added in jQuery 1.4; use .filter(':last') to maintain compatibility with jQuery v1.2.6
            c.$headerIndexed[ indx ] = $temp.length ?
             $temp.not( '.sorter-false' ).length ?
              $temp.not( '.sorter-false' ).filter( ':last' ) :
              $temp.filter( ':last' ) :
             $();
         }
         c.$table.find( c.selectorHeaders ).attr({
            scope: 'col',
            role : 'columnheader'
         });
         // enable/disable sorting
         ts.updateHeader( c );
         if ( c.debug ) {
            console.log( 'Built headers:' + ts.benchmark( timer ) );
            console.log( c.$headers );
         }
      },

      // Use it to add a set of methods to table.config which will be available for all tables.
      // This should be done before table initialization
      addInstanceMethods : function( methods ) {
         $.extend( ts.instanceMethods, methods );
      },

      /*
       █████▄ ▄████▄ █████▄ ▄█████ ██████ █████▄ ▄█████
       ██▄▄██ ██▄▄██ ██▄▄██ ▀█▄    ██▄▄   ██▄▄██ ▀█▄
       ██▀▀▀  ██▀▀██ ██▀██     ▀█▄ ██▀▀   ██▀██     ▀█▄
       ██     ██  ██ ██  ██ █████▀ ██████ ██  ██ █████▀
       */
      setupParsers : function( c, $tbodies ) {
         var rows, list, span, max, colIndex, indx, header, configHeaders,
          noParser, parser, extractor, time, tbody, len,
          table = c.table,
          tbodyIndex = 0,
          debug = {};
         // update table bodies in case we start with an empty table
         c.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );
         tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies;
         len = tbody.length;
         if ( len === 0 ) {
            return c.debug ? console.warn( 'Warning: *Empty table!* Not building a parser cache' ) : '';
         } else if ( c.debug ) {
            time = new Date();
            console[ console.group ? 'group' : 'log' ]( 'Detecting parsers for each column' );
         }
         list = {
            extractors: [],
            parsers: []
         };
         while ( tbodyIndex < len ) {
            rows = tbody[ tbodyIndex ].rows;
            if ( rows.length ) {
               colIndex = 0;
               max = c.columns;
               for ( indx = 0; indx < max; indx++ ) {
                  header = c.$headerIndexed[ colIndex ];
                  if ( header && header.length ) {
                     // get column indexed table cell
                     configHeaders = ts.getColumnData( table, c.headers, colIndex );
                     // get column parser/extractor
                     extractor = ts.getParserById( ts.getData( header, configHeaders, 'extractor' ) );
                     parser = ts.getParserById( ts.getData( header, configHeaders, 'sorter' ) );
                     noParser = ts.getData( header, configHeaders, 'parser' ) === 'false';
                     // empty cells behaviour - keeping emptyToBottom for backwards compatibility
                     c.empties[colIndex] = (
                     ts.getData( header, configHeaders, 'empty' ) ||
                     c.emptyTo || ( c.emptyToBottom ? 'bottom' : 'top' ) ).toLowerCase();
                     // text strings behaviour in numerical sorts
                     c.strings[colIndex] = (
                     ts.getData( header, configHeaders, 'string' ) ||
                     c.stringTo ||
                     'max' ).toLowerCase();
                     if ( noParser ) {
                        parser = ts.getParserById( 'no-parser' );
                     }
                     if ( !extractor ) {
                        // For now, maybe detect someday
                        extractor = false;
                     }
                     if ( !parser ) {
                        parser = ts.detectParserForColumn( c, rows, -1, colIndex );
                     }
                     if ( c.debug ) {
                        debug[ '(' + colIndex + ') ' + header.text() ] = {
                           parser : parser.id,
                           extractor : extractor ? extractor.id : 'none',
                           string : c.strings[ colIndex ],
                           empty  : c.empties[ colIndex ]
                        };
                     }
                     list.parsers[ colIndex ] = parser;
                     list.extractors[ colIndex ] = extractor;
                     span = header[ 0 ].colSpan - 1;
                     if ( span > 0 ) {
                        colIndex += span;
                        max += span;
                        while ( span + 1 > 0 ) {
                           // set colspan columns to use the same parsers & extractors
                           list.parsers[ colIndex - span ] = parser;
                           list.extractors[ colIndex - span ] = extractor;
                           span--;
                        }
                     }
                  }
                  colIndex++;
               }
            }
            tbodyIndex += ( list.parsers.length ) ? len : 1;
         }
         if ( c.debug ) {
            if ( !ts.isEmptyObject( debug ) ) {
               console[ console.table ? 'table' : 'log' ]( debug );
            } else {
               console.warn( '  No parsers detected!' );
            }
            console.log( 'Completed detecting parsers' + ts.benchmark( time ) );
            if ( console.groupEnd ) { console.groupEnd(); }
         }
         c.parsers = list.parsers;
         c.extractors = list.extractors;
      },

      addParser : function( parser ) {
         var indx,
          len = ts.parsers.length,
          add = true;
         for ( indx = 0; indx < len; indx++ ) {
            if ( ts.parsers[ indx ].id.toLowerCase() === parser.id.toLowerCase() ) {
               add = false;
            }
         }
         if ( add ) {
            ts.parsers[ ts.parsers.length ] = parser;
         }
      },

      getParserById : function( name ) {
         /*jshint eqeqeq:false */
         if ( name == 'false' ) { return false; }
         var indx,
          len = ts.parsers.length;
         for ( indx = 0; indx < len; indx++ ) {
            if ( ts.parsers[ indx ].id.toLowerCase() === ( name.toString() ).toLowerCase() ) {
               return ts.parsers[ indx ];
            }
         }
         return false;
      },

      detectParserForColumn : function( c, rows, rowIndex, cellIndex ) {
         var cur, $node, row,
          indx = ts.parsers.length,
          node = false,
          nodeValue = '',
          keepLooking = true;
         while ( nodeValue === '' && keepLooking ) {
            rowIndex++;
            row = rows[ rowIndex ];
            // stop looking after 50 empty rows
            if ( row && rowIndex < 50 ) {
               if ( row.className.indexOf( ts.cssIgnoreRow ) < 0 ) {
                  node = rows[ rowIndex ].cells[ cellIndex ];
                  nodeValue = ts.getElementText( c, node, cellIndex );
                  $node = $( node );
                  if ( c.debug ) {
                     console.log( 'Checking if value was empty on row ' + rowIndex + ', column: ' +
                      cellIndex + ': "' + nodeValue + '"' );
                  }
               }
            } else {
               keepLooking = false;
            }
         }
         while ( --indx >= 0 ) {
            cur = ts.parsers[ indx ];
            // ignore the default text parser because it will always be true
            if ( cur && cur.id !== 'text' && cur.is && cur.is( nodeValue, c.table, node, $node ) ) {
               return cur;
            }
         }
         // nothing found, return the generic parser (text)
         return ts.getParserById( 'text' );
      },

      getElementText : function( c, node, cellIndex ) {
         if ( !node ) { return ''; }
         var tmp,
          extract = c.textExtraction || '',
         // node could be a jquery object
         // http://jsperf.com/jquery-vs-instanceof-jquery/2
          $node = node.jquery ? node : $( node );
         if ( typeof extract === 'string' ) {
            // check data-attribute first when set to 'basic'; don't use node.innerText - it's really slow!
            // http://www.kellegous.com/j/2013/02/27/innertext-vs-textcontent/
            if ( extract === 'basic' && typeof ( tmp = $node.attr( c.textAttribute ) ) !== 'undefined' ) {
               return $.trim( tmp );
            }
            return $.trim( node.textContent || $node.text() );
         } else {
            if ( typeof extract === 'function' ) {
               return $.trim( extract( $node[ 0 ], c.table, cellIndex ) );
            } else if ( typeof ( tmp = ts.getColumnData( c.table, extract, cellIndex ) ) === 'function' ) {
               return $.trim( tmp( $node[ 0 ], c.table, cellIndex ) );
            }
         }
         // fallback
         return $.trim( $node[ 0 ].textContent || $node.text() );
      },

      // centralized function to extract/parse cell contents
      getParsedText : function( c, cell, colIndex, txt ) {
         if ( typeof txt === 'undefined' ) {
            txt = ts.getElementText( c, cell, colIndex );
         }
         // if no parser, make sure to return the txt
         var val = '' + txt,
          parser = c.parsers[ colIndex ],
          extractor = c.extractors[ colIndex ];
         if ( parser ) {
            // do extract before parsing, if there is one
            if ( extractor && typeof extractor.format === 'function' ) {
               txt = extractor.format( txt, c.table, cell, colIndex );
            }
            // allow parsing if the string is empty, previously parsing would change it to zero,
            // in case the parser needs to extract data from the table cell attributes
            val = parser.id === 'no-parser' ? '' :
               // make sure txt is a string (extractor may have converted it)
             parser.format( '' + txt, c.table, cell, colIndex );
            if ( c.ignoreCase && typeof val === 'string' ) {
               val = val.toLowerCase();
            }
         }
         return val;
      },

      /*
       ▄████▄ ▄████▄ ▄████▄ ██  ██ ██████
       ██  ▀▀ ██▄▄██ ██  ▀▀ ██▄▄██ ██▄▄
       ██  ▄▄ ██▀▀██ ██  ▄▄ ██▀▀██ ██▀▀
       ▀████▀ ██  ██ ▀████▀ ██  ██ ██████
       */
      buildCache : function( c, callback, $tbodies ) {
         var cache, val, txt, rowIndex, colIndex, tbodyIndex, $tbody, $row,
          cols, $cells, cell, cacheTime, totalRows, rowData, prevRowData,
          colMax, span, cacheIndex, hasParser, max, len, index,
          table = c.table,
          parsers = c.parsers;
         // update tbody variable
         c.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );
         $tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies,
          c.cache = {};
         c.totalRows = 0;
         // if no parsers found, return - it's an empty table.
         if ( !parsers ) {
            return c.debug ? console.warn( 'Warning: *Empty table!* Not building a cache' ) : '';
         }
         if ( c.debug ) {
            cacheTime = new Date();
         }
         // processing icon
         if ( c.showProcessing ) {
            ts.isProcessing( table, true );
         }
         for ( tbodyIndex = 0; tbodyIndex < $tbody.length; tbodyIndex++ ) {
            colMax = []; // column max value per tbody
            cache = c.cache[ tbodyIndex ] = {
               normalized: [] // array of normalized row data; last entry contains 'rowData' above
               // colMax: #   // added at the end
            };

            totalRows = ( $tbody[ tbodyIndex ] && $tbody[ tbodyIndex ].rows.length ) || 0;
            for ( rowIndex = 0; rowIndex < totalRows; ++rowIndex ) {
               rowData = {
                  // order: original row order #
                  // $row : jQuery Object[]
                  child: [], // child row text (filter widget)
                  raw: []    // original row text
               };
               /** Add the table data to main data array */
               $row = $( $tbody[ tbodyIndex ].rows[ rowIndex ] );
               cols = [];
               // if this is a child row, add it to the last row's children and continue to the next row
               // ignore child row class, if it is the first row
               if ( $row.hasClass( c.cssChildRow ) && rowIndex !== 0 ) {
                  len = cache.normalized.length - 1;
                  prevRowData = cache.normalized[ len ][ c.columns ];
                  prevRowData.$row = prevRowData.$row.add( $row );
                  // add 'hasChild' class name to parent row
                  if ( !$row.prev().hasClass( c.cssChildRow ) ) {
                     $row.prev().addClass( ts.css.cssHasChild );
                  }
                  // save child row content (un-parsed!)
                  $cells = $row.children( 'th, td' );
                  len = prevRowData.child.length;
                  prevRowData.child[ len ] = [];
                  // child row content does not account for colspans/rowspans; so indexing may be off
                  cacheIndex = 0;
                  max = c.columns;
                  for ( colIndex = 0; colIndex < max; colIndex++ ) {
                     cell = $cells[ colIndex ];
                     if ( cell ) {
                        prevRowData.child[ len ][ colIndex ] = ts.getParsedText( c, cell, colIndex );
                        span = $cells[ colIndex ].colSpan - 1;
                        if ( span > 0 ) {
                           cacheIndex += span;
                           max += span;
                        }
                     }
                     cacheIndex++;
                  }
                  // go to the next for loop
                  continue;
               }
               rowData.$row = $row;
               rowData.order = rowIndex; // add original row position to rowCache
               cacheIndex = 0;
               max = c.columns;
               for ( colIndex = 0; colIndex < max; ++colIndex ) {
                  cell = $row[ 0 ].cells[ colIndex ];
                  if ( cell && cacheIndex < c.columns ) {
                     hasParser = typeof parsers[ cacheIndex ] !== 'undefined';
                     if ( !hasParser && c.debug ) {
                        console.warn( 'No parser found for row: ' + rowIndex + ', column: ' + colIndex +
                         '; cell containing: "' + $(cell).text() + '"; does it have a header?' );
                     }
                     val = ts.getElementText( c, cell, cacheIndex );
                     rowData.raw[ cacheIndex ] = val; // save original row text
                     // save raw column text even if there is no parser set
                     txt = ts.getParsedText( c, cell, cacheIndex, val );
                     cols[ cacheIndex ] = txt;
                     if ( hasParser && ( parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {
                        // determine column max value (ignore sign)
                        colMax[ cacheIndex ] = Math.max( Math.abs( txt ) || 0, colMax[ cacheIndex ] || 0 );
                     }
                     // allow colSpan in tbody
                     span = cell.colSpan - 1;
                     if ( span > 0 ) {
                        index = 0;
                        while ( index <= span ) {
                           // duplicate text (or not) to spanned columns
                           // instead of setting duplicate span to empty string, use textExtraction to try to get a value
                           // see http://stackoverflow.com/q/36449711/145346
                           txt = c.duplicateSpan || index === 0 ?
                            val :
                            typeof c.textExtraction !== 'string' ?
                            ts.getElementText( c, cell, cacheIndex + index ) || '' :
                             '';
                           rowData.raw[ cacheIndex + index ] = txt;
                           cols[ cacheIndex + index ] = txt;
                           index++;
                        }
                        cacheIndex += span;
                        max += span;
                     }
                  }
                  cacheIndex++;
               }
               // ensure rowData is always in the same location (after the last column)
               cols[ c.columns ] = rowData;
               cache.normalized[ cache.normalized.length ] = cols;
            }
            cache.colMax = colMax;
            // total up rows, not including child rows
            c.totalRows += cache.normalized.length;

         }
         if ( c.showProcessing ) {
            ts.isProcessing( table ); // remove processing icon
         }
         if ( c.debug ) {
            len = Math.min( 5, c.cache[ 0 ].normalized.length );
            console[ console.group ? 'group' : 'log' ]( 'Building cache for ' + c.totalRows +
             ' rows (showing ' + len + ' rows in log)' + ts.benchmark( cacheTime ) );
            val = {};
            for ( colIndex = 0; colIndex < c.columns; colIndex++ ) {
               for ( cacheIndex = 0; cacheIndex < len; cacheIndex++ ) {
                  if ( !val[ 'row: ' + cacheIndex ] ) {
                     val[ 'row: ' + cacheIndex ] = {};
                  }
                  val[ 'row: ' + cacheIndex ][ c.$headerIndexed[ colIndex ].text() ] =
                   c.cache[ 0 ].normalized[ cacheIndex ][ colIndex ];
               }
            }
            console[ console.table ? 'table' : 'log' ]( val );
            if ( console.groupEnd ) { console.groupEnd(); }
         }
         if ( $.isFunction( callback ) ) {
            callback( table );
         }
      },

      getColumnText : function( table, column, callback, rowFilter ) {
         table = $( table )[0];
         var tbodyIndex, rowIndex, cache, row, tbodyLen, rowLen, raw, parsed, $cell, result,
          hasCallback = typeof callback === 'function',
          allColumns = column === 'all',
          data = { raw : [], parsed: [], $cell: [] },
          c = table.config;
         if ( ts.isEmptyObject( c ) ) {
            if ( c.debug ) {
               console.warn( 'No cache found - aborting getColumnText function!' );
            }
         } else {
            tbodyLen = c.$tbodies.length;
            for ( tbodyIndex = 0; tbodyIndex < tbodyLen; tbodyIndex++ ) {
               cache = c.cache[ tbodyIndex ].normalized;
               rowLen = cache.length;
               for ( rowIndex = 0; rowIndex < rowLen; rowIndex++ ) {
                  row = cache[ rowIndex ];
                  if ( rowFilter && !row[ c.columns ].$row.is( rowFilter ) ) {
                     continue;
                  }
                  result = true;
                  parsed = ( allColumns ) ? row.slice( 0, c.columns ) : row[ column ];
                  row = row[ c.columns ];
                  raw = ( allColumns ) ? row.raw : row.raw[ column ];
                  $cell = ( allColumns ) ? row.$row.children() : row.$row.children().eq( column );
                  if ( hasCallback ) {
                     result = callback({
                        tbodyIndex : tbodyIndex,
                        rowIndex : rowIndex,
                        parsed : parsed,
                        raw : raw,
                        $row : row.$row,
                        $cell : $cell
                     });
                  }
                  if ( result !== false ) {
                     data.parsed[ data.parsed.length ] = parsed;
                     data.raw[ data.raw.length ] = raw;
                     data.$cell[ data.$cell.length ] = $cell;
                  }
               }
            }
            // return everything
            return data;
         }
      },

      /*
       ██  ██ █████▄ █████▄ ▄████▄ ██████ ██████
       ██  ██ ██▄▄██ ██  ██ ██▄▄██   ██   ██▄▄
       ██  ██ ██▀▀▀  ██  ██ ██▀▀██   ██   ██▀▀
       ▀████▀ ██     █████▀ ██  ██   ██   ██████
       */
      setHeadersCss : function( c ) {
         var $sorted, indx, column,
          list = c.sortList,
          len = list.length,
          none = ts.css.sortNone + ' ' + c.cssNone,
          css = [ ts.css.sortAsc + ' ' + c.cssAsc, ts.css.sortDesc + ' ' + c.cssDesc ],
          cssIcon = [ c.cssIconAsc, c.cssIconDesc, c.cssIconNone ],
          aria = [ 'ascending', 'descending' ],
         // find the footer
          $headers = c.$table
           .find( 'tfoot tr' )
           .children( 'td, th' )
           .add( $( c.namespace + '_extra_headers' ) )
           .removeClass( css.join( ' ' ) );
         // remove all header information
         c.$headers
          .removeClass( css.join( ' ' ) )
          .addClass( none )
          .attr( 'aria-sort', 'none' )
          .find( '.' + ts.css.icon )
          .removeClass( cssIcon.join( ' ' ) )
          .addClass( cssIcon[ 2 ] );
         for ( indx = 0; indx < len; indx++ ) {
            // direction = 2 means reset!
            if ( list[ indx ][ 1 ] !== 2 ) {
               // multicolumn sorting updating - see #1005
               // .not(function(){}) needs jQuery 1.4
               // filter(function(i, el){}) <- el is undefined in jQuery v1.2.6
               $sorted = c.$headers.filter( function( i ) {
                  // only include headers that are in the sortList (this includes colspans)
                  var include = true,
                   $el = c.$headers.eq( i ),
                   col = parseInt( $el.attr( 'data-column' ), 10 ),
                   end = col + c.$headers[ i ].colSpan;
                  for ( ; col < end; col++ ) {
                     include = include ? include || ts.isValueInArray( col, c.sortList ) > -1 : false;
                  }
                  return include;
               });

               // choose the :last in case there are nested columns
               $sorted = $sorted
                .not( '.sorter-false' )
                .filter( '[data-column="' + list[ indx ][ 0 ] + '"]' + ( len === 1 ? ':last' : '' ) );
               if ( $sorted.length ) {
                  for ( column = 0; column < $sorted.length; column++ ) {
                     if ( !$sorted[ column ].sortDisabled ) {
                        $sorted
                         .eq( column )
                         .removeClass( none )
                         .addClass( css[ list[ indx ][ 1 ] ] )
                         .attr( 'aria-sort', aria[ list[ indx ][ 1 ] ] )
                         .find( '.' + ts.css.icon )
                         .removeClass( cssIcon[ 2 ] )
                         .addClass( cssIcon[ list[ indx ][ 1 ] ] );
                     }
                  }
                  // add sorted class to footer & extra headers, if they exist
                  if ( $headers.length ) {
                     $headers
                      .filter( '[data-column="' + list[ indx ][ 0 ] + '"]' )
                      .removeClass( none )
                      .addClass( css[ list[ indx ][ 1 ] ] );
                  }
               }
            }
         }
         // add verbose aria labels
         len = c.$headers.length;
         for ( indx = 0; indx < len; indx++ ) {
            ts.setColumnAriaLabel( c, c.$headers.eq( indx ) );
         }
      },

      // nextSort (optional), lets you disable next sort text
      setColumnAriaLabel : function( c, $header, nextSort ) {
         if ( $header.length ) {
            var column = parseInt( $header.attr( 'data-column' ), 10 ),
             tmp = $header.hasClass( ts.css.sortAsc ) ?
              'sortAsc' :
              $header.hasClass( ts.css.sortDesc ) ? 'sortDesc' : 'sortNone',
             txt = $.trim( $header.text() ) + ': ' + ts.language[ tmp ];
            if ( $header.hasClass( 'sorter-false' ) || nextSort === false ) {
               txt += ts.language.sortDisabled;
            } else {
               nextSort = c.sortVars[ column ].order[ ( c.sortVars[ column ].count + 1 ) % ( c.sortReset ? 3 : 2 ) ];
               // if nextSort
               txt += ts.language[ nextSort === 0 ? 'nextAsc' : nextSort === 1 ? 'nextDesc' : 'nextNone' ];
            }
            $header.attr( 'aria-label', txt );
         }
      },

      updateHeader : function( c ) {
         var index, isDisabled, $header, col,
          table = c.table,
          len = c.$headers.length;
         for ( index = 0; index < len; index++ ) {
            $header = c.$headers.eq( index );
            col = ts.getColumnData( table, c.headers, index, true );
            // add 'sorter-false' class if 'parser-false' is set
            isDisabled = ts.getData( $header, col, 'sorter' ) === 'false' || ts.getData( $header, col, 'parser' ) === 'false';
            ts.setColumnSort( c, $header, isDisabled );
         }
      },

      setColumnSort : function( c, $header, isDisabled ) {
         var id = c.table.id;
         $header[ 0 ].sortDisabled = isDisabled;
         $header[ isDisabled ? 'addClass' : 'removeClass' ]( 'sorter-false' )
          .attr( 'aria-disabled', '' + isDisabled );
         // disable tab index on disabled cells
         if ( c.tabIndex ) {
            if ( isDisabled ) {
               $header.removeAttr( 'tabindex' );
            } else {
               $header.attr( 'tabindex', '0' );
            }
         }
         // aria-controls - requires table ID
         if ( id ) {
            if ( isDisabled ) {
               $header.removeAttr( 'aria-controls' );
            } else {
               $header.attr( 'aria-controls', id );
            }
         }
      },

      updateHeaderSortCount : function( c, list ) {
         var col, dir, group, indx, primary, temp, val, order,
          sortList = list || c.sortList,
          len = sortList.length;
         c.sortList = [];
         for ( indx = 0; indx < len; indx++ ) {
            val = sortList[ indx ];
            // ensure all sortList values are numeric - fixes #127
            col = parseInt( val[ 0 ], 10 );
            // prevents error if sorton array is wrong
            if ( col < c.columns ) {

               // set order if not already defined - due to colspan header without associated header cell
               // adding this check prevents a javascript error
               if ( !c.sortVars[ col ].order ) {
                  order = c.sortVars[ col ].order = ts.getOrder( c.sortInitialOrder ) ? [ 1, 0, 2 ] : [ 0, 1, 2 ];
                  c.sortVars[ col ].count = 0;
               }

               order = c.sortVars[ col ].order;
               dir = ( '' + val[ 1 ] ).match( /^(1|d|s|o|n)/ );
               dir = dir ? dir[ 0 ] : '';
               // 0/(a)sc (default), 1/(d)esc, (s)ame, (o)pposite, (n)ext
               switch ( dir ) {
                  case '1' : case 'd' : // descending
                  dir = 1;
                  break;
                  case 's' : // same direction (as primary column)
                     // if primary sort is set to 's', make it ascending
                     dir = primary || 0;
                     break;
                  case 'o' :
                     temp = order[ ( primary || 0 ) % ( c.sortReset ? 3 : 2 ) ];
                     // opposite of primary column; but resets if primary resets
                     dir = temp === 0 ? 1 : temp === 1 ? 0 : 2;
                     break;
                  case 'n' :
                     dir = order[ ( ++c.sortVars[ col ].count ) % ( c.sortReset ? 3 : 2 ) ];
                     break;
                  default : // ascending
                     dir = 0;
                     break;
               }
               primary = indx === 0 ? dir : primary;
               group = [ col, parseInt( dir, 10 ) || 0 ];
               c.sortList[ c.sortList.length ] = group;
               dir = $.inArray( group[ 1 ], order ); // fixes issue #167
               c.sortVars[ col ].count = dir >= 0 ? dir : group[ 1 ] % ( c.sortReset ? 3 : 2 );
            }
         }
      },

      updateAll : function( c, resort, callback ) {
         var table = c.table;
         table.isUpdating = true;
         ts.refreshWidgets( table, true, true );
         ts.buildHeaders( c );
         ts.bindEvents( table, c.$headers, true );
         ts.bindMethods( c );
         ts.commonUpdate( c, resort, callback );
      },

      update : function( c, resort, callback ) {
         var table = c.table;
         table.isUpdating = true;
         // update sorting (if enabled/disabled)
         ts.updateHeader( c );
         ts.commonUpdate( c, resort, callback );
      },

      // simple header update - see #989
      updateHeaders : function( c, callback ) {
         c.table.isUpdating = true;
         ts.buildHeaders( c );
         ts.bindEvents( c.table, c.$headers, true );
         ts.resortComplete( c, callback );
      },

      updateCell : function( c, cell, resort, callback ) {
         if ( ts.isEmptyObject( c.cache ) ) {
            // empty table, do an update instead - fixes #1099
            ts.updateHeader( c );
            ts.commonUpdate( c, resort, callback );
            return;
         }
         c.table.isUpdating = true;
         c.$table.find( c.selectorRemove ).remove();
         // get position from the dom
         var tmp, indx, row, icell, cache, len,
          $tbodies = c.$tbodies,
          $cell = $( cell ),
         // update cache - format: function( s, table, cell, cellIndex )
         // no closest in jQuery v1.2.6
          tbodyIndex = $tbodies
           .index( $.fn.closest ? $cell.closest( 'tbody' ) : $cell.parents( 'tbody' ).filter( ':first' ) ),
          tbcache = c.cache[ tbodyIndex ],
          $row = $.fn.closest ? $cell.closest( 'tr' ) : $cell.parents( 'tr' ).filter( ':first' );
         cell = $cell[ 0 ]; // in case cell is a jQuery object
         // tbody may not exist if update is initialized while tbody is removed for processing
         if ( $tbodies.length && tbodyIndex >= 0 ) {
            row = $tbodies.eq( tbodyIndex ).find( 'tr' ).index( $row );
            cache = tbcache.normalized[ row ];
            len = $row[ 0 ].cells.length;
            if ( len !== c.columns ) {
               // colspan in here somewhere!
               icell = 0;
               tmp = false;
               for ( indx = 0; indx < len; indx++ ) {
                  if ( !tmp && $row[ 0 ].cells[ indx ] !== cell ) {
                     icell += $row[ 0 ].cells[ indx ].colSpan;
                  } else {
                     tmp = true;
                  }
               }
            } else {
               icell = $cell.index();
            }
            tmp = ts.getElementText( c, cell, icell ); // raw
            cache[ c.columns ].raw[ icell ] = tmp;
            tmp = ts.getParsedText( c, cell, icell, tmp );
            cache[ icell ] = tmp; // parsed
            cache[ c.columns ].$row = $row;
            if ( ( c.parsers[ icell ].type || '' ).toLowerCase() === 'numeric' ) {
               // update column max value (ignore sign)
               tbcache.colMax[ icell ] = Math.max( Math.abs( tmp ) || 0, tbcache.colMax[ icell ] || 0 );
            }
            tmp = resort !== 'undefined' ? resort : c.resort;
            if ( tmp !== false ) {
               // widgets will be reapplied
               ts.checkResort( c, tmp, callback );
            } else {
               // don't reapply widgets is resort is false, just in case it causes
               // problems with element focus
               ts.resortComplete( c, callback );
            }
         } else {
            if ( c.debug ) {
               console.error( 'updateCell aborted, tbody missing or not within the indicated table' );
            }
            c.table.isUpdating = false;
         }
      },

      addRows : function( c, $row, resort, callback ) {
         var txt, val, tbodyIndex, rowIndex, rows, cellIndex, len, order,
          cacheIndex, rowData, cells, cell, span,
         // allow passing a row string if only one non-info tbody exists in the table
          valid = typeof $row === 'string' && c.$tbodies.length === 1 && /<tr/.test( $row || '' ),
          table = c.table;
         if ( valid ) {
            $row = $( $row );
            c.$tbodies.append( $row );
         } else if ( !$row ||
             // row is a jQuery object?
          !( $row instanceof jQuery ) ||
             // row contained in the table?
          ( $.fn.closest ? $row.closest( 'table' )[ 0 ] : $row.parents( 'table' )[ 0 ] ) !== c.table ) {
            if ( c.debug ) {
               console.error( 'addRows method requires (1) a jQuery selector reference to rows that have already ' +
                'been added to the table, or (2) row HTML string to be added to a table with only one tbody' );
            }
            return false;
         }
         table.isUpdating = true;
         if ( ts.isEmptyObject( c.cache ) ) {
            // empty table, do an update instead - fixes #450
            ts.updateHeader( c );
            ts.commonUpdate( c, resort, callback );
         } else {
            rows = $row.filter( 'tr' ).attr( 'role', 'row' ).length;
            tbodyIndex = c.$tbodies.index( $row.parents( 'tbody' ).filter( ':first' ) );
            // fixes adding rows to an empty table - see issue #179
            if ( !( c.parsers && c.parsers.length ) ) {
               ts.setupParsers( c );
            }
            // add each row
            for ( rowIndex = 0; rowIndex < rows; rowIndex++ ) {
               cacheIndex = 0;
               len = $row[ rowIndex ].cells.length;
               order = c.cache[ tbodyIndex ].normalized.length;
               cells = [];
               rowData = {
                  child : [],
                  raw : [],
                  $row : $row.eq( rowIndex ),
                  order : order
               };
               // add each cell
               for ( cellIndex = 0; cellIndex < len; cellIndex++ ) {
                  cell = $row[ rowIndex ].cells[ cellIndex ];
                  txt = ts.getElementText( c, cell, cacheIndex );
                  rowData.raw[ cacheIndex ] = txt;
                  val = ts.getParsedText( c, cell, cacheIndex, txt );
                  cells[ cacheIndex ] = val;
                  if ( ( c.parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {
                     // update column max value (ignore sign)
                     c.cache[ tbodyIndex ].colMax[ cacheIndex ] =
                      Math.max( Math.abs( val ) || 0, c.cache[ tbodyIndex ].colMax[ cacheIndex ] || 0 );
                  }
                  span = cell.colSpan - 1;
                  if ( span > 0 ) {
                     cacheIndex += span;
                  }
                  cacheIndex++;
               }
               // add the row data to the end
               cells[ c.columns ] = rowData;
               // update cache
               c.cache[ tbodyIndex ].normalized[ order ] = cells;
            }
            // resort using current settings
            ts.checkResort( c, resort, callback );
         }
      },

      updateCache : function( c, callback, $tbodies ) {
         // rebuild parsers
         if ( !( c.parsers && c.parsers.length ) ) {
            ts.setupParsers( c, $tbodies );
         }
         // rebuild the cache map
         ts.buildCache( c, callback, $tbodies );
      },

      // init flag (true) used by pager plugin to prevent widget application
      // renamed from appendToTable
      appendCache : function( c, init ) {
         var parsed, totalRows, $tbody, $curTbody, rowIndex, tbodyIndex, appendTime,
          table = c.table,
          wo = c.widgetOptions,
          $tbodies = c.$tbodies,
          rows = [],
          cache = c.cache;
         // empty table - fixes #206/#346
         if ( ts.isEmptyObject( cache ) ) {
            // run pager appender in case the table was just emptied
            return c.appender ? c.appender( table, rows ) :
             table.isUpdating ? c.$table.triggerHandler( 'updateComplete', table ) : ''; // Fixes #532
         }
         if ( c.debug ) {
            appendTime = new Date();
         }
         for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
            $tbody = $tbodies.eq( tbodyIndex );
            if ( $tbody.length ) {
               // detach tbody for manipulation
               $curTbody = ts.processTbody( table, $tbody, true );
               parsed = cache[ tbodyIndex ].normalized;
               totalRows = parsed.length;
               for ( rowIndex = 0; rowIndex < totalRows; rowIndex++ ) {
                  rows[rows.length] = parsed[ rowIndex ][ c.columns ].$row;
                  // removeRows used by the pager plugin; don't render if using ajax - fixes #411
                  if ( !c.appender || ( c.pager && ( !c.pager.removeRows || !wo.pager_removeRows ) && !c.pager.ajax ) ) {
                     $curTbody.append( parsed[ rowIndex ][ c.columns ].$row );
                  }
               }
               // restore tbody
               ts.processTbody( table, $curTbody, false );
            }
         }
         if ( c.appender ) {
            c.appender( table, rows );
         }
         if ( c.debug ) {
            console.log( 'Rebuilt table' + ts.benchmark( appendTime ) );
         }
         // apply table widgets; but not before ajax completes
         if ( !init && !c.appender ) {
            ts.applyWidget( table );
         }
         if ( table.isUpdating ) {
            c.$table.triggerHandler( 'updateComplete', table );
         }
      },

      commonUpdate : function( c, resort, callback ) {
         // remove rows/elements before update
         c.$table.find( c.selectorRemove ).remove();
         // rebuild parsers
         ts.setupParsers( c );
         // rebuild the cache map
         ts.buildCache( c );
         ts.checkResort( c, resort, callback );
      },

      /*
       ▄█████ ▄████▄ █████▄ ██████ ██ █████▄ ▄████▄
       ▀█▄    ██  ██ ██▄▄██   ██   ██ ██  ██ ██ ▄▄▄
       ▀█▄ ██  ██ ██▀██    ██   ██ ██  ██ ██ ▀██
       █████▀ ▀████▀ ██  ██   ██   ██ ██  ██ ▀████▀
       */
      initSort : function( c, cell, event ) {
         if ( c.table.isUpdating ) {
            // let any updates complete before initializing a sort
            return setTimeout( function(){
               ts.initSort( c, cell, event );
            }, 50 );
         }

         var arry, indx, headerIndx, dir, temp, tmp, $header,
          notMultiSort = !event[ c.sortMultiSortKey ],
          table = c.table,
          len = c.$headers.length,
         // get current column index
          col = parseInt( $( cell ).attr( 'data-column' ), 10 ),
          order = c.sortVars[ col ].order;

         // Only call sortStart if sorting is enabled
         c.$table.triggerHandler( 'sortStart', table );
         // get current column sort order
         c.sortVars[ col ].count =
          event[ c.sortResetKey ] ? 2 : ( c.sortVars[ col ].count + 1 ) % ( c.sortReset ? 3 : 2 );
         // reset all sorts on non-current column - issue #30
         if ( c.sortRestart ) {
            for ( headerIndx = 0; headerIndx < len; headerIndx++ ) {
               $header = c.$headers.eq( headerIndx );
               tmp = parseInt( $header.attr( 'data-column' ), 10 );
               // only reset counts on columns that weren't just clicked on and if not included in a multisort
               if ( col !== tmp && ( notMultiSort || $header.hasClass( ts.css.sortNone ) ) ) {
                  c.sortVars[ tmp ].count = -1;
               }
            }
         }
         // user only wants to sort on one column
         if ( notMultiSort ) {
            // flush the sort list
            c.sortList = [];
            c.last.sortList = [];
            if ( c.sortForce !== null ) {
               arry = c.sortForce;
               for ( indx = 0; indx < arry.length; indx++ ) {
                  if ( arry[ indx ][ 0 ] !== col ) {
                     c.sortList[ c.sortList.length ] = arry[ indx ];
                  }
               }
            }
            // add column to sort list
            dir = order[ c.sortVars[ col ].count ];
            if ( dir < 2 ) {
               c.sortList[ c.sortList.length ] = [ col, dir ];
               // add other columns if header spans across multiple
               if ( cell.colSpan > 1 ) {
                  for ( indx = 1; indx < cell.colSpan; indx++ ) {
                     c.sortList[ c.sortList.length ] = [ col + indx, dir ];
                     // update count on columns in colSpan
                     c.sortVars[ col + indx ].count = $.inArray( dir, order );
                  }
               }
            }
            // multi column sorting
         } else {
            // get rid of the sortAppend before adding more - fixes issue #115 & #523
            c.sortList = $.extend( [], c.last.sortList );

            // the user has clicked on an already sorted column
            if ( ts.isValueInArray( col, c.sortList ) >= 0 ) {
               // reverse the sorting direction
               for ( indx = 0; indx < c.sortList.length; indx++ ) {
                  tmp = c.sortList[ indx ];
                  if ( tmp[ 0 ] === col ) {
                     // order.count seems to be incorrect when compared to cell.count
                     tmp[ 1 ] = order[ c.sortVars[ col ].count ];
                     if ( tmp[1] === 2 ) {
                        c.sortList.splice( indx, 1 );
                        c.sortVars[ col ].count = -1;
                     }
                  }
               }
            } else {
               // add column to sort list array
               dir = order[ c.sortVars[ col ].count ];
               if ( dir < 2 ) {
                  c.sortList[ c.sortList.length ] = [ col, dir ];
                  // add other columns if header spans across multiple
                  if ( cell.colSpan > 1 ) {
                     for ( indx = 1; indx < cell.colSpan; indx++ ) {
                        c.sortList[ c.sortList.length ] = [ col + indx, dir ];
                        // update count on columns in colSpan
                        c.sortVars[ col + indx ].count = $.inArray( dir, order );
                     }
                  }
               }
            }
         }
         // save sort before applying sortAppend
         c.last.sortList = $.extend( [], c.sortList );
         if ( c.sortList.length && c.sortAppend ) {
            arry = $.isArray( c.sortAppend ) ? c.sortAppend : c.sortAppend[ c.sortList[ 0 ][ 0 ] ];
            if ( !ts.isEmptyObject( arry ) ) {
               for ( indx = 0; indx < arry.length; indx++ ) {
                  if ( arry[ indx ][ 0 ] !== col && ts.isValueInArray( arry[ indx ][ 0 ], c.sortList ) < 0 ) {
                     dir = arry[ indx ][ 1 ];
                     temp = ( '' + dir ).match( /^(a|d|s|o|n)/ );
                     if ( temp ) {
                        tmp = c.sortList[ 0 ][ 1 ];
                        switch ( temp[ 0 ] ) {
                           case 'd' :
                              dir = 1;
                              break;
                           case 's' :
                              dir = tmp;
                              break;
                           case 'o' :
                              dir = tmp === 0 ? 1 : 0;
                              break;
                           case 'n' :
                              dir = ( tmp + 1 ) % ( c.sortReset ? 3 : 2 );
                              break;
                           default:
                              dir = 0;
                              break;
                        }
                     }
                     c.sortList[ c.sortList.length ] = [ arry[ indx ][ 0 ], dir ];
                  }
               }
            }
         }
         // sortBegin event triggered immediately before the sort
         c.$table.triggerHandler( 'sortBegin', table );
         // setTimeout needed so the processing icon shows up
         setTimeout( function() {
            // set css for headers
            ts.setHeadersCss( c );
            ts.multisort( c );
            ts.appendCache( c );
            c.$table.triggerHandler( 'sortBeforeEnd', table );
            c.$table.triggerHandler( 'sortEnd', table );
         }, 1 );
      },

      // sort multiple columns
      multisort : function( c ) { /*jshint loopfunc:true */
         var tbodyIndex, sortTime, colMax, rows,
          table = c.table,
          dir = 0,
          textSorter = c.textSorter || '',
          sortList = c.sortList,
          sortLen = sortList.length,
          len = c.$tbodies.length;
         if ( c.serverSideSorting || ts.isEmptyObject( c.cache ) ) {
            // empty table - fixes #206/#346
            return;
         }
         if ( c.debug ) { sortTime = new Date(); }
         for ( tbodyIndex = 0; tbodyIndex < len; tbodyIndex++ ) {
            colMax = c.cache[ tbodyIndex ].colMax;
            rows = c.cache[ tbodyIndex ].normalized;

            rows.sort( function( a, b ) {
               var sortIndex, num, col, order, sort, x, y;
               // rows is undefined here in IE, so don't use it!
               for ( sortIndex = 0; sortIndex < sortLen; sortIndex++ ) {
                  col = sortList[ sortIndex ][ 0 ];
                  order = sortList[ sortIndex ][ 1 ];
                  // sort direction, true = asc, false = desc
                  dir = order === 0;

                  if ( c.sortStable && a[ col ] === b[ col ] && sortLen === 1 ) {
                     return a[ c.columns ].order - b[ c.columns ].order;
                  }

                  // fallback to natural sort since it is more robust
                  num = /n/i.test( ts.getSortType( c.parsers, col ) );
                  if ( num && c.strings[ col ] ) {
                     // sort strings in numerical columns
                     if ( typeof ( ts.string[ c.strings[ col ] ] ) === 'boolean' ) {
                        num = ( dir ? 1 : -1 ) * ( ts.string[ c.strings[ col ] ] ? -1 : 1 );
                     } else {
                        num = ( c.strings[ col ] ) ? ts.string[ c.strings[ col ] ] || 0 : 0;
                     }
                     // fall back to built-in numeric sort
                     // var sort = $.tablesorter['sort' + s]( a[col], b[col], dir, colMax[col], table );
                     sort = c.numberSorter ? c.numberSorter( a[ col ], b[ col ], dir, colMax[ col ], table ) :
                      ts[ 'sortNumeric' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], num, colMax[ col ], col, c );
                  } else {
                     // set a & b depending on sort direction
                     x = dir ? a : b;
                     y = dir ? b : a;
                     // text sort function
                     if ( typeof textSorter === 'function' ) {
                        // custom OVERALL text sorter
                        sort = textSorter( x[ col ], y[ col ], dir, col, table );
                     } else if ( typeof textSorter === 'object' && textSorter.hasOwnProperty( col ) ) {
                        // custom text sorter for a SPECIFIC COLUMN
                        sort = textSorter[ col ]( x[ col ], y[ col ], dir, col, table );
                     } else {
                        // fall back to natural sort
                        sort = ts[ 'sortNatural' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], col, c );
                     }
                  }
                  if ( sort ) { return sort; }
               }
               return a[ c.columns ].order - b[ c.columns ].order;
            });
         }
         if ( c.debug ) {
            console.log( 'Applying sort ' + sortList.toString() + ts.benchmark( sortTime ) );
         }
      },

      resortComplete : function( c, callback ) {
         if ( c.table.isUpdating ) {
            c.$table.triggerHandler( 'updateComplete', c.table );
         }
         if ( $.isFunction( callback ) ) {
            callback( c.table );
         }
      },

      checkResort : function( c, resort, callback ) {
         var sortList = $.isArray( resort ) ? resort : c.sortList,
         // if no resort parameter is passed, fallback to config.resort (true by default)
          resrt = typeof resort === 'undefined' ? c.resort : resort;
         // don't try to resort if the table is still processing
         // this will catch spamming of the updateCell method
         if ( resrt !== false && !c.serverSideSorting && !c.table.isProcessing ) {
            if ( sortList.length ) {
               ts.sortOn( c, sortList, function() {
                  ts.resortComplete( c, callback );
               }, true );
            } else {
               ts.sortReset( c, function() {
                  ts.resortComplete( c, callback );
                  ts.applyWidget( c.table, false );
               } );
            }
         } else {
            ts.resortComplete( c, callback );
            ts.applyWidget( c.table, false );
         }
      },

      sortOn : function( c, list, callback, init ) {
         var table = c.table;
         c.$table.triggerHandler( 'sortStart', table );
         // update header count index
         ts.updateHeaderSortCount( c, list );
         // set css for headers
         ts.setHeadersCss( c );
         // fixes #346
         if ( c.delayInit && ts.isEmptyObject( c.cache ) ) {
            ts.buildCache( c );
         }
         c.$table.triggerHandler( 'sortBegin', table );
         // sort the table and append it to the dom
         ts.multisort( c );
         ts.appendCache( c, init );
         c.$table.triggerHandler( 'sortBeforeEnd', table );
         c.$table.triggerHandler( 'sortEnd', table );
         ts.applyWidget( table );
         if ( $.isFunction( callback ) ) {
            callback( table );
         }
      },

      sortReset : function( c, callback ) {
         c.sortList = [];
         ts.setHeadersCss( c );
         ts.multisort( c );
         ts.appendCache( c );
         if ( $.isFunction( callback ) ) {
            callback( c.table );
         }
      },

      getSortType : function( parsers, column ) {
         return ( parsers && parsers[ column ] ) ? parsers[ column ].type || '' : '';
      },

      getOrder : function( val ) {
         // look for 'd' in 'desc' order; return true
         return ( /^d/i.test( val ) || val === 1 );
      },

      // Natural sort - https://github.com/overset/javascript-natural-sort (date sorting removed)
      // this function will only accept strings, or you'll see 'TypeError: undefined is not a function'
      // I could add a = a.toString(); b = b.toString(); but it'll slow down the sort overall
      sortNatural : function( a, b ) {
         if ( a === b ) { return 0; }
         var aNum, bNum, aFloat, bFloat, indx, max,
          regex = ts.regex;
         // first try and sort Hex codes
         if ( regex.hex.test( b ) ) {
            aNum = parseInt( a.match( regex.hex ), 16 );
            bNum = parseInt( b.match( regex.hex ), 16 );
            if ( aNum < bNum ) { return -1; }
            if ( aNum > bNum ) { return 1; }
         }
         // chunk/tokenize
         aNum = a.replace( regex.chunk, '\\0$1\\0' ).replace( regex.chunks, '' ).split( '\\0' );
         bNum = b.replace( regex.chunk, '\\0$1\\0' ).replace( regex.chunks, '' ).split( '\\0' );
         max = Math.max( aNum.length, bNum.length );
         // natural sorting through split numeric strings and default strings
         for ( indx = 0; indx < max; indx++ ) {
            // find floats not starting with '0', string or 0 if not defined
            aFloat = isNaN( aNum[ indx ] ) ? aNum[ indx ] || 0 : parseFloat( aNum[ indx ] ) || 0;
            bFloat = isNaN( bNum[ indx ] ) ? bNum[ indx ] || 0 : parseFloat( bNum[ indx ] ) || 0;
            // handle numeric vs string comparison - number < string - (Kyle Adams)
            if ( isNaN( aFloat ) !== isNaN( bFloat ) ) { return isNaN( aFloat ) ? 1 : -1; }
            // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
            if ( typeof aFloat !== typeof bFloat ) {
               aFloat += '';
               bFloat += '';
            }
            if ( aFloat < bFloat ) { return -1; }
            if ( aFloat > bFloat ) { return 1; }
         }
         return 0;
      },

      sortNaturalAsc : function( a, b, col, c ) {
         if ( a === b ) { return 0; }
         var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
         if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }
         if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }
         return ts.sortNatural( a, b );
      },

      sortNaturalDesc : function( a, b, col, c ) {
         if ( a === b ) { return 0; }
         var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
         if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }
         if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }
         return ts.sortNatural( b, a );
      },

      // basic alphabetical sort
      sortText : function( a, b ) {
         return a > b ? 1 : ( a < b ? -1 : 0 );
      },

      // return text string value by adding up ascii value
      // so the text is somewhat sorted when using a digital sort
      // this is NOT an alphanumeric sort
      getTextValue : function( val, num, max ) {
         if ( max ) {
            // make sure the text value is greater than the max numerical value (max)
            var indx,
             len = val ? val.length : 0,
             n = max + num;
            for ( indx = 0; indx < len; indx++ ) {
               n += val.charCodeAt( indx );
            }
            return num * n;
         }
         return 0;
      },

      sortNumericAsc : function( a, b, num, max, col, c ) {
         if ( a === b ) { return 0; }
         var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
         if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }
         if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }
         if ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }
         if ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }
         return a - b;
      },

      sortNumericDesc : function( a, b, num, max, col, c ) {
         if ( a === b ) { return 0; }
         var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
         if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }
         if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }
         if ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }
         if ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }
         return b - a;
      },

      sortNumeric : function( a, b ) {
         return a - b;
      },

      /*
       ██ ██ ██ ██ █████▄ ▄████▄ ██████ ██████ ▄█████
       ██ ██ ██ ██ ██  ██ ██ ▄▄▄ ██▄▄     ██   ▀█▄
       ██ ██ ██ ██ ██  ██ ██ ▀██ ██▀▀     ██      ▀█▄
       ███████▀ ██ █████▀ ▀████▀ ██████   ██   █████▀
       */
      addWidget : function( widget ) {
         if ( widget.id && !ts.isEmptyObject( ts.getWidgetById( widget.id ) ) ) {
            console.warn( '"' + widget.id + '" widget was loaded more than once!' );
         }
         ts.widgets[ ts.widgets.length ] = widget;
      },

      hasWidget : function( $table, name ) {
         $table = $( $table );
         return $table.length && $table[ 0 ].config && $table[ 0 ].config.widgetInit[ name ] || false;
      },

      getWidgetById : function( name ) {
         var indx, widget,
          len = ts.widgets.length;
         for ( indx = 0; indx < len; indx++ ) {
            widget = ts.widgets[ indx ];
            if ( widget && widget.id && widget.id.toLowerCase() === name.toLowerCase() ) {
               return widget;
            }
         }
      },

      applyWidgetOptions : function( table ) {
         var indx, widget,
          c = table.config,
          len = c.widgets.length;
         if ( len ) {
            for ( indx = 0; indx < len; indx++ ) {
               widget = ts.getWidgetById( c.widgets[ indx ] );
               if ( widget && widget.options ) {
                  c.widgetOptions = $.extend( true, {}, widget.options, c.widgetOptions );
               }
            }
         }
      },

      addWidgetFromClass : function( table ) {
         var len, indx,
          c = table.config,
         // look for widgets to apply from table class
         // don't match from 'ui-widget-content'; use \S instead of \w to include widgets
         // with dashes in the name, e.g. "widget-test-2" extracts out "test-2"
          regex = '^' + c.widgetClass.replace( ts.regex.templateName, '(\\S+)+' ) + '$',
          widgetClass = new RegExp( regex, 'g' ),
         // split up table class (widget id's can include dashes) - stop using match
         // otherwise only one widget gets extracted, see #1109
          widgets = ( table.className || '' ).split( ts.regex.spaces );
         if ( widgets.length ) {
            len = widgets.length;
            for ( indx = 0; indx < len; indx++ ) {
               if ( widgets[ indx ].match( widgetClass ) ) {
                  c.widgets[ c.widgets.length ] = widgets[ indx ].replace( widgetClass, '$1' );
               }
            }
         }
      },

      applyWidgetId : function( table, id, init ) {
         table = $(table)[0];
         var applied, time, name,
          c = table.config,
          wo = c.widgetOptions,
          widget = ts.getWidgetById( id );
         if ( widget ) {
            name = widget.id;
            applied = false;
            // add widget name to option list so it gets reapplied after sorting, filtering, etc
            if ( $.inArray( name, c.widgets ) < 0 ) {
               c.widgets[ c.widgets.length ] = name;
            }
            if ( c.debug ) { time = new Date(); }

            if ( init || !( c.widgetInit[ name ] ) ) {
               // set init flag first to prevent calling init more than once (e.g. pager)
               c.widgetInit[ name ] = true;
               if ( table.hasInitialized ) {
                  // don't reapply widget options on tablesorter init
                  ts.applyWidgetOptions( table );
               }
               if ( typeof widget.init === 'function' ) {
                  applied = true;
                  if ( c.debug ) {
                     console[ console.group ? 'group' : 'log' ]( 'Initializing ' + name + ' widget' );
                  }
                  widget.init( table, widget, c, wo );
               }
            }
            if ( !init && typeof widget.format === 'function' ) {
               applied = true;
               if ( c.debug ) {
                  console[ console.group ? 'group' : 'log' ]( 'Updating ' + name + ' widget' );
               }
               widget.format( table, c, wo, false );
            }
            if ( c.debug ) {
               if ( applied ) {
                  console.log( 'Completed ' + ( init ? 'initializing ' : 'applying ' ) + name + ' widget' + ts.benchmark( time ) );
                  if ( console.groupEnd ) { console.groupEnd(); }
               }
            }
         }
      },

      applyWidget : function( table, init, callback ) {
         table = $( table )[ 0 ]; // in case this is called externally
         var indx, len, names, widget, time,
          c = table.config,
          widgets = [];
         // prevent numerous consecutive widget applications
         if ( init !== false && table.hasInitialized && ( table.isApplyingWidgets || table.isUpdating ) ) {
            return;
         }
         if ( c.debug ) { time = new Date(); }
         ts.addWidgetFromClass( table );
         // prevent "tablesorter-ready" from firing multiple times in a row
         clearTimeout( c.timerReady );
         if ( c.widgets.length ) {
            table.isApplyingWidgets = true;
            // ensure unique widget ids
            c.widgets = $.grep( c.widgets, function( val, index ) {
               return $.inArray( val, c.widgets ) === index;
            });
            names = c.widgets || [];
            len = names.length;
            // build widget array & add priority as needed
            for ( indx = 0; indx < len; indx++ ) {
               widget = ts.getWidgetById( names[ indx ] );
               if ( widget && widget.id ) {
                  // set priority to 10 if not defined
                  if ( !widget.priority ) { widget.priority = 10; }
                  widgets[ indx ] = widget;
               } else if ( c.debug ) {
                  console.warn( '"' + names[ indx ] + '" widget code does not exist!' );
               }
            }
            // sort widgets by priority
            widgets.sort( function( a, b ) {
               return a.priority < b.priority ? -1 : a.priority === b.priority ? 0 : 1;
            });
            // add/update selected widgets
            len = widgets.length;
            if ( c.debug ) {
               console[ console.group ? 'group' : 'log' ]( 'Start ' + ( init ? 'initializing' : 'applying' ) + ' widgets' );
            }
            for ( indx = 0; indx < len; indx++ ) {
               widget = widgets[ indx ];
               if ( widget && widget.id ) {
                  ts.applyWidgetId( table, widget.id, init );
               }
            }
            if ( c.debug && console.groupEnd ) { console.groupEnd(); }
            // callback executed on init only
            if ( !init && typeof callback === 'function' ) {
               callback( table );
            }
         }
         c.timerReady = setTimeout( function() {
            table.isApplyingWidgets = false;
            $.data( table, 'lastWidgetApplication', new Date() );
            c.$table.triggerHandler( 'tablesorter-ready' );
         }, 10 );
         if ( c.debug ) {
            widget = c.widgets.length;
            console.log( 'Completed ' +
             ( init === true ? 'initializing ' : 'applying ' ) + widget +
             ' widget' + ( widget !== 1 ? 's' : '' ) + ts.benchmark( time ) );
         }
      },

      removeWidget : function( table, name, refreshing ) {
         table = $( table )[ 0 ];
         var index, widget, indx, len,
          c = table.config;
         // if name === true, add all widgets from $.tablesorter.widgets
         if ( name === true ) {
            name = [];
            len = ts.widgets.length;
            for ( indx = 0; indx < len; indx++ ) {
               widget = ts.widgets[ indx ];
               if ( widget && widget.id ) {
                  name[ name.length ] = widget.id;
               }
            }
         } else {
            // name can be either an array of widgets names,
            // or a space/comma separated list of widget names
            name = ( $.isArray( name ) ? name.join( ',' ) : name || '' ).toLowerCase().split( /[\s,]+/ );
         }
         len = name.length;
         for ( index = 0; index < len; index++ ) {
            widget = ts.getWidgetById( name[ index ] );
            indx = $.inArray( name[ index ], c.widgets );
            // don't remove the widget from config.widget if refreshing
            if ( indx >= 0 && refreshing !== true ) {
               c.widgets.splice( indx, 1 );
            }
            if ( widget && widget.remove ) {
               if ( c.debug ) {
                  console.log( ( refreshing ? 'Refreshing' : 'Removing' ) + ' "' + name[ index ] + '" widget' );
               }
               widget.remove( table, c, c.widgetOptions, refreshing );
               c.widgetInit[ name[ index ] ] = false;
            }
         }
      },

      refreshWidgets : function( table, doAll, dontapply ) {
         table = $( table )[ 0 ]; // see issue #243
         var indx, widget,
          c = table.config,
          curWidgets = c.widgets,
          widgets = ts.widgets,
          len = widgets.length,
          list = [],
          callback = function( table ) {
             $( table ).triggerHandler( 'refreshComplete' );
          };
         // remove widgets not defined in config.widgets, unless doAll is true
         for ( indx = 0; indx < len; indx++ ) {
            widget = widgets[ indx ];
            if ( widget && widget.id && ( doAll || $.inArray( widget.id, curWidgets ) < 0 ) ) {
               list[ list.length ] = widget.id;
            }
         }
         ts.removeWidget( table, list.join( ',' ), true );
         if ( dontapply !== true ) {
            // call widget init if
            ts.applyWidget( table, doAll || false, callback );
            if ( doAll ) {
               // apply widget format
               ts.applyWidget( table, false, callback );
            }
         } else {
            callback( table );
         }
      },

      /*
       ██  ██ ██████ ██ ██     ██ ██████ ██ ██████ ▄█████
       ██  ██   ██   ██ ██     ██   ██   ██ ██▄▄   ▀█▄
       ██  ██   ██   ██ ██     ██   ██   ██ ██▀▀      ▀█▄
       ▀████▀   ██   ██ ██████ ██   ██   ██ ██████ █████▀
       */
      benchmark : function( diff ) {
         return ( ' ( ' + ( new Date().getTime() - diff.getTime() ) + 'ms )' );
      },
      // deprecated ts.log
      log : function() {
         console.log( arguments );
      },

      // $.isEmptyObject from jQuery v1.4
      isEmptyObject : function( obj ) {
         /*jshint forin: false */
         for ( var name in obj ) {
            return false;
         }
         return true;
      },

      isValueInArray : function( column, arry ) {
         var indx,
          len = arry && arry.length || 0;
         for ( indx = 0; indx < len; indx++ ) {
            if ( arry[ indx ][ 0 ] === column ) {
               return indx;
            }
         }
         return -1;
      },

      formatFloat : function( str, table ) {
         if ( typeof str !== 'string' || str === '' ) { return str; }
         // allow using formatFloat without a table; defaults to US number format
         var num,
          usFormat = table && table.config ? table.config.usNumberFormat !== false :
           typeof table !== 'undefined' ? table : true;
         if ( usFormat ) {
            // US Format - 1,234,567.89 -> 1234567.89
            str = str.replace( ts.regex.comma, '' );
         } else {
            // German Format = 1.234.567,89 -> 1234567.89
            // French Format = 1 234 567,89 -> 1234567.89
            str = str.replace( ts.regex.digitNonUS, '' ).replace( ts.regex.comma, '.' );
         }
         if ( ts.regex.digitNegativeTest.test( str ) ) {
            // make (#) into a negative number -> (10) = -10
            str = str.replace( ts.regex.digitNegativeReplace, '-$1' );
         }
         num = parseFloat( str );
         // return the text instead of zero
         return isNaN( num ) ? $.trim( str ) : num;
      },

      isDigit : function( str ) {
         // replace all unwanted chars and match
         return isNaN( str ) ?
          ts.regex.digitTest.test( str.toString().replace( ts.regex.digitReplace, '' ) ) :
         str !== '';
      },

      // computeTableHeaderCellIndexes from:
      // http://www.javascripttoolbox.com/lib/table/examples.php
      // http://www.javascripttoolbox.com/temp/table_cellindex.html
      computeColumnIndex : function( $rows, c ) {
         var i, j, k, l, cell, cells, rowIndex, rowSpan, colSpan, firstAvailCol,
         // total columns has been calculated, use it to set the matrixrow
          columns = c && c.columns || 0,
          matrix = [],
          matrixrow = new Array( columns );
         for ( i = 0; i < $rows.length; i++ ) {
            cells = $rows[ i ].cells;
            for ( j = 0; j < cells.length; j++ ) {
               cell = cells[ j ];
               rowIndex = cell.parentNode.rowIndex;
               rowSpan = cell.rowSpan || 1;
               colSpan = cell.colSpan || 1;
               if ( typeof matrix[ rowIndex ] === 'undefined' ) {
                  matrix[ rowIndex ] = [];
               }
               // Find first available column in the first row
               for ( k = 0; k < matrix[ rowIndex ].length + 1; k++ ) {
                  if ( typeof matrix[ rowIndex ][ k ] === 'undefined' ) {
                     firstAvailCol = k;
                     break;
                  }
               }
               // jscs:disable disallowEmptyBlocks
               if ( columns && cell.cellIndex === firstAvailCol ) {
                  // don't to anything
               } else if ( cell.setAttribute ) {
                  // jscs:enable disallowEmptyBlocks
                  // add data-column (setAttribute = IE8+)
                  cell.setAttribute( 'data-column', firstAvailCol );
               } else {
                  // remove once we drop support for IE7 - 1/12/2016
                  $( cell ).attr( 'data-column', firstAvailCol );
               }
               for ( k = rowIndex; k < rowIndex + rowSpan; k++ ) {
                  if ( typeof matrix[ k ] === 'undefined' ) {
                     matrix[ k ] = [];
                  }
                  matrixrow = matrix[ k ];
                  for ( l = firstAvailCol; l < firstAvailCol + colSpan; l++ ) {
                     matrixrow[ l ] = 'x';
                  }
               }
            }
         }
         return matrixrow.length;
      },

      // automatically add a colgroup with col elements set to a percentage width
      fixColumnWidth : function( table ) {
         table = $( table )[ 0 ];
         var overallWidth, percent, $tbodies, len, index,
          c = table.config,
          $colgroup = c.$table.children( 'colgroup' );
         // remove plugin-added colgroup, in case we need to refresh the widths
         if ( $colgroup.length && $colgroup.hasClass( ts.css.colgroup ) ) {
            $colgroup.remove();
         }
         if ( c.widthFixed && c.$table.children( 'colgroup' ).length === 0 ) {
            $colgroup = $( '<colgroup class="' + ts.css.colgroup + '">' );
            overallWidth = c.$table.width();
            // only add col for visible columns - fixes #371
            $tbodies = c.$tbodies.find( 'tr:first' ).children( ':visible' );
            len = $tbodies.length;
            for ( index = 0; index < len; index++ ) {
               percent = parseInt( ( $tbodies.eq( index ).width() / overallWidth ) * 1000, 10 ) / 10 + '%';
               $colgroup.append( $( '<col>' ).css( 'width', percent ) );
            }
            c.$table.prepend( $colgroup );
         }
      },

      // get sorter, string, empty, etc options for each column from
      // jQuery data, metadata, header option or header class name ('sorter-false')
      // priority = jQuery data > meta > headers option > header class name
      getData : function( header, configHeader, key ) {
         var meta, cl4ss,
          val = '',
          $header = $( header );
         if ( !$header.length ) { return ''; }
         meta = $.metadata ? $header.metadata() : false;
         cl4ss = ' ' + ( $header.attr( 'class' ) || '' );
         if ( typeof $header.data( key ) !== 'undefined' ||
          typeof $header.data( key.toLowerCase() ) !== 'undefined' ) {
            // 'data-lockedOrder' is assigned to 'lockedorder'; but 'data-locked-order' is assigned to 'lockedOrder'
            // 'data-sort-initial-order' is assigned to 'sortInitialOrder'
            val += $header.data( key ) || $header.data( key.toLowerCase() );
         } else if ( meta && typeof meta[ key ] !== 'undefined' ) {
            val += meta[ key ];
         } else if ( configHeader && typeof configHeader[ key ] !== 'undefined' ) {
            val += configHeader[ key ];
         } else if ( cl4ss !== ' ' && cl4ss.match( ' ' + key + '-' ) ) {
            // include sorter class name 'sorter-text', etc; now works with 'sorter-my-custom-parser'
            val = cl4ss.match( new RegExp( '\\s' + key + '-([\\w-]+)' ) )[ 1 ] || '';
         }
         return $.trim( val );
      },

      getColumnData : function( table, obj, indx, getCell, $headers ) {
         if ( typeof obj === 'undefined' || obj === null ) { return; }
         table = $( table )[ 0 ];
         var $header, key,
          c = table.config,
          $cells = ( $headers || c.$headers ),
         // c.$headerIndexed is not defined initially
          $cell = c.$headerIndexed && c.$headerIndexed[ indx ] ||
           $cells.filter( '[data-column="' + indx + '"]:last' );
         if ( obj[ indx ] ) {
            return getCell ? obj[ indx ] : obj[ $cells.index( $cell ) ];
         }
         for ( key in obj ) {
            if ( typeof key === 'string' ) {
               $header = $cell
               // header cell with class/id
                .filter( key )
                // find elements within the header cell with cell/id
                .add( $cell.find( key ) );
               if ( $header.length ) {
                  return obj[ key ];
               }
            }
         }
         return;
      },

      // *** Process table ***
      // add processing indicator
      isProcessing : function( $table, toggle, $headers ) {
         $table = $( $table );
         var c = $table[ 0 ].config,
         // default to all headers
          $header = $headers || $table.find( '.' + ts.css.header );
         if ( toggle ) {
            // don't use sortList if custom $headers used
            if ( typeof $headers !== 'undefined' && c.sortList.length > 0 ) {
               // get headers from the sortList
               $header = $header.filter( function() {
                  // get data-column from attr to keep compatibility with jQuery 1.2.6
                  return this.sortDisabled ?
                   false :
                  ts.isValueInArray( parseFloat( $( this ).attr( 'data-column' ) ), c.sortList ) >= 0;
               });
            }
            $table.add( $header ).addClass( ts.css.processing + ' ' + c.cssProcessing );
         } else {
            $table.add( $header ).removeClass( ts.css.processing + ' ' + c.cssProcessing );
         }
      },

      // detach tbody but save the position
      // don't use tbody because there are portions that look for a tbody index (updateCell)
      processTbody : function( table, $tb, getIt ) {
         table = $( table )[ 0 ];
         if ( getIt ) {
            table.isProcessing = true;
            $tb.before( '<colgroup class="tablesorter-savemyplace"/>' );
            return $.fn.detach ? $tb.detach() : $tb.remove();
         }
         var holdr = $( table ).find( 'colgroup.tablesorter-savemyplace' );
         $tb.insertAfter( holdr );
         holdr.remove();
         table.isProcessing = false;
      },

      clearTableBody : function( table ) {
         $( table )[ 0 ].config.$tbodies.children().detach();
      },

      // used when replacing accented characters during sorting
      characterEquivalents : {
         'a' : '\u00e1\u00e0\u00e2\u00e3\u00e4\u0105\u00e5', // áàâãäąå
         'A' : '\u00c1\u00c0\u00c2\u00c3\u00c4\u0104\u00c5', // ÁÀÂÃÄĄÅ
         'c' : '\u00e7\u0107\u010d', // çćč
         'C' : '\u00c7\u0106\u010c', // ÇĆČ
         'e' : '\u00e9\u00e8\u00ea\u00eb\u011b\u0119', // éèêëěę
         'E' : '\u00c9\u00c8\u00ca\u00cb\u011a\u0118', // ÉÈÊËĚĘ
         'i' : '\u00ed\u00ec\u0130\u00ee\u00ef\u0131', // íìİîïı
         'I' : '\u00cd\u00cc\u0130\u00ce\u00cf', // ÍÌİÎÏ
         'o' : '\u00f3\u00f2\u00f4\u00f5\u00f6\u014d', // óòôõöō
         'O' : '\u00d3\u00d2\u00d4\u00d5\u00d6\u014c', // ÓÒÔÕÖŌ
         'ss': '\u00df', // ß (s sharp)
         'SS': '\u1e9e', // ẞ (Capital sharp s)
         'u' : '\u00fa\u00f9\u00fb\u00fc\u016f', // úùûüů
         'U' : '\u00da\u00d9\u00db\u00dc\u016e' // ÚÙÛÜŮ
      },

      replaceAccents : function( str ) {
         var chr,
          acc = '[',
          eq = ts.characterEquivalents;
         if ( !ts.characterRegex ) {
            ts.characterRegexArray = {};
            for ( chr in eq ) {
               if ( typeof chr === 'string' ) {
                  acc += eq[ chr ];
                  ts.characterRegexArray[ chr ] = new RegExp( '[' + eq[ chr ] + ']', 'g' );
               }
            }
            ts.characterRegex = new RegExp( acc + ']' );
         }
         if ( ts.characterRegex.test( str ) ) {
            for ( chr in eq ) {
               if ( typeof chr === 'string' ) {
                  str = str.replace( ts.characterRegexArray[ chr ], chr );
               }
            }
         }
         return str;
      },

      // restore headers
      restoreHeaders : function( table ) {
         var index, $cell,
          c = $( table )[ 0 ].config,
          $headers = c.$table.find( c.selectorHeaders ),
          len = $headers.length;
         // don't use c.$headers here in case header cells were swapped
         for ( index = 0; index < len; index++ ) {
            $cell = $headers.eq( index );
            // only restore header cells if it is wrapped
            // because this is also used by the updateAll method
            if ( $cell.find( '.' + ts.css.headerIn ).length ) {
               $cell.html( c.headerContent[ index ] );
            }
         }
      },

      destroy : function( table, removeClasses, callback ) {
         table = $( table )[ 0 ];
         if ( !table.hasInitialized ) { return; }
         // remove all widgets
         ts.removeWidget( table, true, false );
         var events,
          $t = $( table ),
          c = table.config,
          debug = c.debug,
          $h = $t.find( 'thead:first' ),
          $r = $h.find( 'tr.' + ts.css.headerRow ).removeClass( ts.css.headerRow + ' ' + c.cssHeaderRow ),
          $f = $t.find( 'tfoot:first > tr' ).children( 'th, td' );
         if ( removeClasses === false && $.inArray( 'uitheme', c.widgets ) >= 0 ) {
            // reapply uitheme classes, in case we want to maintain appearance
            $t.triggerHandler( 'applyWidgetId', [ 'uitheme' ] );
            $t.triggerHandler( 'applyWidgetId', [ 'zebra' ] );
         }
         // remove widget added rows, just in case
         $h.find( 'tr' ).not( $r ).remove();
         // disable tablesorter - not using .unbind( namespace ) because namespacing was
         // added in jQuery v1.4.3 - see http://api.jquery.com/event.namespace/
         events = 'sortReset update updateRows updateAll updateHeaders updateCell addRows updateComplete sorton ' +
          'appendCache updateCache applyWidgetId applyWidgets refreshWidgets removeWidget destroy mouseup mouseleave ' +
          'keypress sortBegin sortEnd resetToLoadState '.split( ' ' )
           .join( c.namespace + ' ' );
         $t
          .removeData( 'tablesorter' )
          .unbind( events.replace( ts.regex.spaces, ' ' ) );
         c.$headers
          .add( $f )
          .removeClass( [ ts.css.header, c.cssHeader, c.cssAsc, c.cssDesc, ts.css.sortAsc, ts.css.sortDesc, ts.css.sortNone ].join( ' ' ) )
          .removeAttr( 'data-column' )
          .removeAttr( 'aria-label' )
          .attr( 'aria-disabled', 'true' );
         $r
          .find( c.selectorSort )
          .unbind( ( 'mousedown mouseup keypress '.split( ' ' ).join( c.namespace + ' ' ) ).replace( ts.regex.spaces, ' ' ) );
         ts.restoreHeaders( table );
         $t.toggleClass( ts.css.table + ' ' + c.tableClass + ' tablesorter-' + c.theme, removeClasses === false );
         // clear flag in case the plugin is initialized again
         table.hasInitialized = false;
         delete table.config.cache;
         if ( typeof callback === 'function' ) {
            callback( table );
         }
         if ( debug ) {
            console.log( 'tablesorter has been removed' );
         }
      }

   };

   $.fn.tablesorter = function( settings ) {
      return this.each( function() {
         var table = this,
         // merge & extend config options
          c = $.extend( true, {}, ts.defaults, settings, ts.instanceMethods );
         // save initial settings
         c.originalSettings = settings;
         // create a table from data (build table widget)
         if ( !table.hasInitialized && ts.buildTable && this.nodeName !== 'TABLE' ) {
            // return the table (in case the original target is the table's container)
            ts.buildTable( table, c );
         } else {
            ts.setup( table, c );
         }
      });
   };

   // set up debug logs
   if ( !( window.console && window.console.log ) ) {
      // access $.tablesorter.logs for browsers that don't have a console...
      ts.logs = [];
      /*jshint -W020 */
      console = {};
      console.log = console.warn = console.error = console.table = function() {
         var arg = arguments.length > 1 ? arguments : arguments[0];
         ts.logs[ ts.logs.length ] = { date: Date.now(), log: arg };
      };
   }

   // add default parsers
   ts.addParser({
      id : 'no-parser',
      is : function() {
         return false;
      },
      format : function() {
         return '';
      },
      type : 'text'
   });

   ts.addParser({
      id : 'text',
      is : function() {
         return true;
      },
      format : function( str, table ) {
         var c = table.config;
         if ( str ) {
            str = $.trim( c.ignoreCase ? str.toLocaleLowerCase() : str );
            str = c.sortLocaleCompare ? ts.replaceAccents( str ) : str;
         }
         return str;
      },
      type : 'text'
   });

   ts.regex.nondigit = /[^\w,. \-()]/g;
   ts.addParser({
      id : 'digit',
      is : function( str ) {
         return ts.isDigit( str );
      },
      format : function( str, table ) {
         var num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );
         return str && typeof num === 'number' ? num :
          str ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;
      },
      type : 'numeric'
   });

   ts.regex.currencyReplace = /[+\-,. ]/g;
   ts.regex.currencyTest = /^\(?\d+[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]|[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]\d+\)?$/;
   ts.addParser({
      id : 'currency',
      is : function( str ) {
         str = ( str || '' ).replace( ts.regex.currencyReplace, '' );
         // test for £$€¤¥¢
         return ts.regex.currencyTest.test( str );
      },
      format : function( str, table ) {
         var num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );
         return str && typeof num === 'number' ? num :
          str ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;
      },
      type : 'numeric'
   });

   // too many protocols to add them all https://en.wikipedia.org/wiki/URI_scheme
   // now, this regex can be updated before initialization
   ts.regex.urlProtocolTest =   /^(https?|ftp|file):\/\//;
   ts.regex.urlProtocolReplace = /(https?|ftp|file):\/\//;
   ts.addParser({
      id : 'url',
      is : function( str ) {
         return ts.regex.urlProtocolTest.test( str );
      },
      format : function( str ) {
         return str ? $.trim( str.replace( ts.regex.urlProtocolReplace, '' ) ) : str;
      },
      parsed : true, // filter widget flag
      type : 'text'
   });

   ts.regex.dash = /-/g;
   ts.regex.isoDate = /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/;
   ts.addParser({
      id : 'isoDate',
      is : function( str ) {
         return ts.regex.isoDate.test( str );
      },
      format : function( str, table ) {
         var date = str ? new Date( str.replace( ts.regex.dash, '/' ) ) : str;
         return date instanceof Date && isFinite( date ) ? date.getTime() : str;
      },
      type : 'numeric'
   });

   ts.regex.percent = /%/g;
   ts.regex.percentTest = /(\d\s*?%|%\s*?\d)/;
   ts.addParser({
      id : 'percent',
      is : function( str ) {
         return ts.regex.percentTest.test( str ) && str.length < 15;
      },
      format : function( str, table ) {
         return str ? ts.formatFloat( str.replace( ts.regex.percent, '' ), table ) : str;
      },
      type : 'numeric'
   });

   // added image parser to core v2.17.9
   ts.addParser({
      id : 'image',
      is : function( str, table, node, $node ) {
         return $node.find( 'img' ).length > 0;
      },
      format : function( str, table, cell ) {
         return $( cell ).find( 'img' ).attr( table.config.imgAttr || 'alt' ) || str;
      },
      parsed : true, // filter widget flag
      type : 'text'
   });

   ts.regex.dateReplace = /(\S)([AP]M)$/i; // used by usLongDate & time parser
   ts.regex.usLongDateTest1 = /^[A-Z]{3,10}\.?\s+\d{1,2},?\s+(\d{4})(\s+\d{1,2}:\d{2}(:\d{2})?(\s+[AP]M)?)?$/i;
   ts.regex.usLongDateTest2 = /^\d{1,2}\s+[A-Z]{3,10}\s+\d{4}/i;
   ts.addParser({
      id : 'usLongDate',
      is : function( str ) {
         // two digit years are not allowed cross-browser
         // Jan 01, 2013 12:34:56 PM or 01 Jan 2013
         return ts.regex.usLongDateTest1.test( str ) || ts.regex.usLongDateTest2.test( str );
      },
      format : function( str, table ) {
         var date = str ? new Date( str.replace( ts.regex.dateReplace, '$1 $2' ) ) : str;
         return date instanceof Date && isFinite( date ) ? date.getTime() : str;
      },
      type : 'numeric'
   });

   // testing for ##-##-#### or ####-##-##, so it's not perfect; time can be included
   ts.regex.shortDateTest = /(^\d{1,2}[\/\s]\d{1,2}[\/\s]\d{4})|(^\d{4}[\/\s]\d{1,2}[\/\s]\d{1,2})/;
   // escaped "-" because JSHint in Firefox was showing it as an error
   ts.regex.shortDateReplace = /[\-.,]/g;
   // XXY covers MDY & DMY formats
   ts.regex.shortDateXXY = /(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/;
   ts.regex.shortDateYMD = /(\d{4})[\/\s](\d{1,2})[\/\s](\d{1,2})/;
   ts.convertFormat = function( dateString, format ) {
      dateString = ( dateString || '' )
       .replace( ts.regex.spaces, ' ' )
       .replace( ts.regex.shortDateReplace, '/' );
      if ( format === 'mmddyyyy' ) {
         dateString = dateString.replace( ts.regex.shortDateXXY, '$3/$1/$2' );
      } else if ( format === 'ddmmyyyy' ) {
         dateString = dateString.replace( ts.regex.shortDateXXY, '$3/$2/$1' );
      } else if ( format === 'yyyymmdd' ) {
         dateString = dateString.replace( ts.regex.shortDateYMD, '$1/$2/$3' );
      }
      var date = new Date( dateString );
      return date instanceof Date && isFinite( date ) ? date.getTime() : '';
   };

   ts.addParser({
      id : 'shortDate', // 'mmddyyyy', 'ddmmyyyy' or 'yyyymmdd'
      is : function( str ) {
         str = ( str || '' ).replace( ts.regex.spaces, ' ' ).replace( ts.regex.shortDateReplace, '/' );
         return ts.regex.shortDateTest.test( str );
      },
      format : function( str, table, cell, cellIndex ) {
         if ( str ) {
            var c = table.config,
             $header = c.$headerIndexed[ cellIndex ],
             format = $header.length && $header.data( 'dateFormat' ) ||
              ts.getData( $header, ts.getColumnData( table, c.headers, cellIndex ), 'dateFormat' ) ||
              c.dateFormat;
            // save format because getData can be slow...
            if ( $header.length ) {
               $header.data( 'dateFormat', format );
            }
            return ts.convertFormat( str, format ) || str;
         }
         return str;
      },
      type : 'numeric'
   });

   // match 24 hour time & 12 hours time + am/pm - see http://regexr.com/3c3tk
   ts.regex.timeTest = /^([1-9]|1[0-2]):([0-5]\d)(\s[AP]M)$|^((?:[01]\d|[2][0-4]):[0-5]\d)$/i;
   ts.regex.timeMatch = /([1-9]|1[0-2]):([0-5]\d)(\s[AP]M)|((?:[01]\d|[2][0-4]):[0-5]\d)/i;
   ts.addParser({
      id : 'time',
      is : function( str ) {
         return ts.regex.timeTest.test( str );
      },
      format : function( str, table ) {
         // isolate time... ignore month, day and year
         var temp,
          timePart = ( str || '' ).match( ts.regex.timeMatch ),
          orig = new Date( str ),
         // no time component? default to 00:00 by leaving it out, but only if str is defined
          time = str && ( timePart !== null ? timePart[ 0 ] : '00:00 AM' ),
          date = time ? new Date( '2000/01/01 ' + time.replace( ts.regex.dateReplace, '$1 $2' ) ) : time;
         if ( date instanceof Date && isFinite( date ) ) {
            temp = orig instanceof Date && isFinite( orig ) ? orig.getTime() : 0;
            // if original string was a valid date, add it to the decimal so the column sorts in some kind of order
            // luckily new Date() ignores the decimals
            return temp ? parseFloat( date.getTime() + '.' + orig.getTime() ) : date.getTime();
         }
         return str;
      },
      type : 'numeric'
   });

   ts.addParser({
      id : 'metadata',
      is : function() {
         return false;
      },
      format : function( str, table, cell ) {
         var c = table.config,
          p = ( !c.parserMetadataName ) ? 'sortValue' : c.parserMetadataName;
         return $( cell ).metadata()[ p ];
      },
      type : 'numeric'
   });

   /*
    ██████ ██████ █████▄ █████▄ ▄████▄
    ▄█▀  ██▄▄   ██▄▄██ ██▄▄██ ██▄▄██
    ▄█▀    ██▀▀   ██▀▀██ ██▀▀█  ██▀▀██
    ██████ ██████ █████▀ ██  ██ ██  ██
    */
   // add default widgets
   ts.addWidget({
      id : 'zebra',
      priority : 90,
      format : function( table, c, wo ) {
         var $visibleRows, $row, count, isEven, tbodyIndex, rowIndex, len,
          child = new RegExp( c.cssChildRow, 'i' ),
          $tbodies = c.$tbodies.add( $( c.namespace + '_extra_table' ).children( 'tbody:not(.' + c.cssInfoBlock + ')' ) );
         for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
            // loop through the visible rows
            count = 0;
            $visibleRows = $tbodies.eq( tbodyIndex ).children( 'tr:visible' ).not( c.selectorRemove );
            len = $visibleRows.length;
            for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {
               $row = $visibleRows.eq( rowIndex );
               // style child rows the same way the parent row was styled
               if ( !child.test( $row[ 0 ].className ) ) { count++; }
               isEven = ( count % 2 === 0 );
               $row
                .removeClass( wo.zebra[ isEven ? 1 : 0 ] )
                .addClass( wo.zebra[ isEven ? 0 : 1 ] );
            }
         }
      },
      remove : function( table, c, wo, refreshing ) {
         if ( refreshing ) { return; }
         var tbodyIndex, $tbody,
          $tbodies = c.$tbodies,
          toRemove = ( wo.zebra || [ 'even', 'odd' ] ).join( ' ' );
         for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ){
            $tbody = ts.processTbody( table, $tbodies.eq( tbodyIndex ), true ); // remove tbody
            $tbody.children().removeClass( toRemove );
            ts.processTbody( table, $tbody, false ); // restore tbody
         }
      }
   });

})( jQuery );

/*! Widget: stickyHeaders - updated 4/1/2016 (v2.25.7) *//*
 * Requires tablesorter v2.8+ and jQuery 1.4.3+
 * by Rob Garrison
 */
(function ($, window) {
   'use strict';
   var ts = $.tablesorter || {};

   $.extend(ts.css, {
      sticky    : 'tablesorter-stickyHeader', // stickyHeader
      stickyVis : 'tablesorter-sticky-visible',
      stickyHide: 'tablesorter-sticky-hidden',
      stickyWrap: 'tablesorter-sticky-wrapper'
   });

   // Add a resize event to table headers
   ts.addHeaderResizeEvent = function(table, disable, settings) {
      table = $(table)[0]; // make sure we're using a dom element
      if ( !table.config ) { return; }
      var defaults = {
          timer : 250
       },
       options = $.extend({}, defaults, settings),
       c = table.config,
       wo = c.widgetOptions,
       checkSizes = function( triggerEvent ) {
          var index, headers, $header, sizes, width, height,
           len = c.$headers.length;
          wo.resize_flag = true;
          headers = [];
          for ( index = 0; index < len; index++ ) {
             $header = c.$headers.eq( index );
             sizes = $header.data( 'savedSizes' ) || [ 0, 0 ]; // fixes #394
             width = $header[0].offsetWidth;
             height = $header[0].offsetHeight;
             if ( width !== sizes[0] || height !== sizes[1] ) {
                $header.data( 'savedSizes', [ width, height ] );
                headers.push( $header[0] );
             }
          }
          if ( headers.length && triggerEvent !== false ) {
             c.$table.triggerHandler( 'resize', [ headers ] );
          }
          wo.resize_flag = false;
       };
      clearInterval(wo.resize_timer);
      if (disable) {
         wo.resize_flag = false;
         return false;
      }
      checkSizes( false );
      wo.resize_timer = setInterval(function() {
         if (wo.resize_flag) { return; }
         checkSizes();
      }, options.timer);
   };

   // Sticky headers based on this awesome article:
   // http://css-tricks.com/13465-persistent-headers/
   // and https://github.com/jmosbech/StickyTableHeaders by Jonas Mosbech
   // **************************
   ts.addWidget({
      id: 'stickyHeaders',
      priority: 60, // sticky widget must be initialized after the filter widget!
      options: {
         stickyHeaders : '',       // extra class name added to the sticky header row
         stickyHeaders_attachTo : null, // jQuery selector or object to attach sticky header to
         stickyHeaders_xScroll : null, // jQuery selector or object to monitor horizontal scroll position (defaults: xScroll > attachTo > window)
         stickyHeaders_yScroll : null, // jQuery selector or object to monitor vertical scroll position (defaults: yScroll > attachTo > window)
         stickyHeaders_offset : 0, // number or jquery selector targeting the position:fixed element
         stickyHeaders_filteredToTop: true, // scroll table top into view after filtering
         stickyHeaders_cloneId : '-sticky', // added to table ID, if it exists
         stickyHeaders_addResizeEvent : true, // trigger 'resize' event on headers
         stickyHeaders_includeCaption : true, // if false and a caption exist, it won't be included in the sticky header
         stickyHeaders_zIndex : 2 // The zIndex of the stickyHeaders, allows the user to adjust this to their needs
      },
      format: function(table, c, wo) {
         // filter widget doesn't initialize on an empty table. Fixes #449
         if ( c.$table.hasClass('hasStickyHeaders') || ($.inArray('filter', c.widgets) >= 0 && !c.$table.hasClass('hasFilters')) ) {
            return;
         }
         var index, len, $t,
          $table = c.$table,
         // add position: relative to attach element, hopefully it won't cause trouble.
          $attach = $(wo.stickyHeaders_attachTo),
          namespace = c.namespace + 'stickyheaders ',
         // element to watch for the scroll event
          $yScroll = $(wo.stickyHeaders_yScroll || wo.stickyHeaders_attachTo || window),
          $xScroll = $(wo.stickyHeaders_xScroll || wo.stickyHeaders_attachTo || window),
          $thead = $table.children('thead:first'),
          $header = $thead.children('tr').not('.sticky-false').children(),
          $tfoot = $table.children('tfoot'),
          $stickyOffset = isNaN(wo.stickyHeaders_offset) ? $(wo.stickyHeaders_offset) : '',
          stickyOffset = $stickyOffset.length ? $stickyOffset.height() || 0 : parseInt(wo.stickyHeaders_offset, 10) || 0,
         // is this table nested? If so, find parent sticky header wrapper (div, not table)
          $nestedSticky = $table.parent().closest('.' + ts.css.table).hasClass('hasStickyHeaders') ?
           $table.parent().closest('table.tablesorter')[0].config.widgetOptions.$sticky.parent() : [],
          nestedStickyTop = $nestedSticky.length ? $nestedSticky.height() : 0,
         // clone table, then wrap to make sticky header
          $stickyTable = wo.$sticky = $table.clone()
           .addClass('containsStickyHeaders ' + ts.css.sticky + ' ' + wo.stickyHeaders + ' ' + c.namespace.slice(1) + '_extra_table' )
           .wrap('<div class="' + ts.css.stickyWrap + '">'),
          $stickyWrap = $stickyTable.parent()
           .addClass(ts.css.stickyHide)
           .css({
              position   : $attach.length ? 'absolute' : 'fixed',
              padding    : parseInt( $stickyTable.parent().parent().css('padding-left'), 10 ),
              top        : stickyOffset + nestedStickyTop,
              left       : 0,
              visibility : 'hidden',
              zIndex     : wo.stickyHeaders_zIndex || 2
           }),
          $stickyThead = $stickyTable.children('thead:first'),
          $stickyCells,
          laststate = '',
          spacing = 0,
          setWidth = function($orig, $clone){
             var index, width, border, $cell, $this,
              $cells = $orig.filter(':visible'),
              len = $cells.length;
             for ( index = 0; index < len; index++ ) {
                $cell = $clone.filter(':visible').eq(index);
                $this = $cells.eq(index);
                // code from https://github.com/jmosbech/StickyTableHeaders
                if ($this.css('box-sizing') === 'border-box') {
                   width = $this.outerWidth();
                } else {
                   if ($cell.css('border-collapse') === 'collapse') {
                      if (window.getComputedStyle) {
                         width = parseFloat( window.getComputedStyle($this[0], null).width );
                      } else {
                         // ie8 only
                         border = parseFloat( $this.css('border-width') );
                         width = $this.outerWidth() - parseFloat( $this.css('padding-left') ) - parseFloat( $this.css('padding-right') ) - border;
                      }
                   } else {
                      width = $this.width();
                   }
                }
                $cell.css({
                   'width': width,
                   'min-width': width,
                   'max-width': width
                });
             }
          },
          resizeHeader = function() {
             stickyOffset = $stickyOffset.length ? $stickyOffset.height() || 0 : parseInt(wo.stickyHeaders_offset, 10) || 0;
             spacing = 0;
             $stickyWrap.css({
                left : $attach.length ? parseInt($attach.css('padding-left'), 10) || 0 :
                $table.offset().left - parseInt($table.css('margin-left'), 10) - $xScroll.scrollLeft() - spacing,
                width: $table.outerWidth()
             });
             setWidth( $table, $stickyTable );
             setWidth( $header, $stickyCells );
          },
          scrollSticky = function( resizing ) {
             if (!$table.is(':visible')) { return; } // fixes #278
             // Detect nested tables - fixes #724
             nestedStickyTop = $nestedSticky.length ? $nestedSticky.offset().top - $yScroll.scrollTop() + $nestedSticky.height() : 0;
             var offset = $table.offset(),
              yWindow = $.isWindow( $yScroll[0] ), // $.isWindow needs jQuery 1.4.3
              xWindow = $.isWindow( $xScroll[0] ),
             // scrollTop = ( $attach.length ? $attach.offset().top : $yScroll.scrollTop() ) + stickyOffset + nestedStickyTop,
              scrollTop = ( $attach.length ? ( yWindow ? $yScroll.scrollTop() : $yScroll.offset().top ) : $yScroll.scrollTop() ) + stickyOffset + nestedStickyTop,
              tableHeight = $table.height() - ($stickyWrap.height() + ($tfoot.height() || 0)),
              isVisible = ( scrollTop > offset.top ) && ( scrollTop < offset.top + tableHeight ) ? 'visible' : 'hidden',
              cssSettings = { visibility : isVisible };

             if ($attach.length) {
                cssSettings.top = yWindow ? scrollTop - $attach.offset().top : $attach.scrollTop();
             }
             if (xWindow) {
                // adjust when scrolling horizontally - fixes issue #143
                cssSettings.left = $table.offset().left - parseInt($table.css('margin-left'), 10) - $xScroll.scrollLeft() - spacing;
             }
             if ($nestedSticky.length) {
                cssSettings.top = ( cssSettings.top || 0 ) + stickyOffset + nestedStickyTop;
             }
             $stickyWrap
              .removeClass( ts.css.stickyVis + ' ' + ts.css.stickyHide )
              .addClass( isVisible === 'visible' ? ts.css.stickyVis : ts.css.stickyHide )
              .css(cssSettings);
             if (isVisible !== laststate || resizing) {
                // make sure the column widths match
                resizeHeader();
                laststate = isVisible;
             }
          };
         // only add a position relative if a position isn't already defined
         if ($attach.length && !$attach.css('position')) {
            $attach.css('position', 'relative');
         }
         // fix clone ID, if it exists - fixes #271
         if ($stickyTable.attr('id')) { $stickyTable[0].id += wo.stickyHeaders_cloneId; }
         // clear out cloned table, except for sticky header
         // include caption & filter row (fixes #126 & #249) - don't remove cells to get correct cell indexing
         $stickyTable.find('thead:gt(0), tr.sticky-false').hide();
         $stickyTable.find('tbody, tfoot').remove();
         $stickyTable.find('caption').toggle(wo.stickyHeaders_includeCaption);
         // issue #172 - find td/th in sticky header
         $stickyCells = $stickyThead.children().children();
         $stickyTable.css({ height:0, width:0, margin: 0 });
         // remove resizable block
         $stickyCells.find('.' + ts.css.resizer).remove();
         // update sticky header class names to match real header after sorting
         $table
          .addClass('hasStickyHeaders')
          .bind('pagerComplete' + namespace, function() {
             resizeHeader();
          });

         ts.bindEvents(table, $stickyThead.children().children('.' + ts.css.header));

         // add stickyheaders AFTER the table. If the table is selected by ID, the original one (first) will be returned.
         $table.after( $stickyWrap );

         // onRenderHeader is defined, we need to do something about it (fixes #641)
         if (c.onRenderHeader) {
            $t = $stickyThead.children('tr').children();
            len = $t.length;
            for ( index = 0; index < len; index++ ) {
               // send second parameter
               c.onRenderHeader.apply( $t.eq( index ), [ index, c, $stickyTable ] );
            }
         }

         // make it sticky!
         $xScroll.add($yScroll)
          .unbind( ('scroll resize '.split(' ').join( namespace )).replace(/\s+/g, ' ') )
          .bind('scroll resize '.split(' ').join( namespace ), function( event ) {
             scrollSticky( event.type === 'resize' );
          });
         c.$table
          .unbind('stickyHeadersUpdate' + namespace)
          .bind('stickyHeadersUpdate' + namespace, function(){
             scrollSticky( true );
          });

         if (wo.stickyHeaders_addResizeEvent) {
            ts.addHeaderResizeEvent(table);
         }

         // look for filter widget
         if ($table.hasClass('hasFilters') && wo.filter_columnFilters) {
            // scroll table into view after filtering, if sticky header is active - #482
            $table.bind('filterEnd' + namespace, function() {
               // $(':focus') needs jQuery 1.6+
               var $td = $(document.activeElement).closest('td'),
                column = $td.parent().children().index($td);
               // only scroll if sticky header is active
               if ($stickyWrap.hasClass(ts.css.stickyVis) && wo.stickyHeaders_filteredToTop) {
                  // scroll to original table (not sticky clone)
                  window.scrollTo(0, $table.position().top);
                  // give same input/select focus; check if c.$filters exists; fixes #594
                  if (column >= 0 && c.$filters) {
                     c.$filters.eq(column).find('a, select, input').filter(':visible').focus();
                  }
               }
            });
            ts.filter.bindSearch( $table, $stickyCells.find('.' + ts.css.filter) );
            // support hideFilters
            if (wo.filter_hideFilters) {
               ts.filter.hideFilters(c, $stickyTable);
            }
         }

         // resize table (Firefox)
         if (wo.stickyHeaders_addResizeEvent) {
            $table.bind('resize' + c.namespace + 'stickyheaders', function() {
               resizeHeader();
            });
         }

         $table.triggerHandler('stickyHeadersInit');

      },
      remove: function(table, c, wo) {
         var namespace = c.namespace + 'stickyheaders ';
         c.$table
          .removeClass('hasStickyHeaders')
          .unbind( ('pagerComplete resize filterEnd stickyHeadersUpdate '.split(' ').join(namespace)).replace(/\s+/g, ' ') )
          .next('.' + ts.css.stickyWrap).remove();
         if (wo.$sticky && wo.$sticky.length) { wo.$sticky.remove(); } // remove cloned table
         $(window)
          .add(wo.stickyHeaders_xScroll)
          .add(wo.stickyHeaders_yScroll)
          .add(wo.stickyHeaders_attachTo)
          .unbind( ('scroll resize '.split(' ').join(namespace)).replace(/\s+/g, ' ') );
         ts.addHeaderResizeEvent(table, true);
      }
   });

})(jQuery, window);
   /* eslint-disable */

(function()
{
   'use strict';

   var circleRadius = 6;
   var minScaleExtent = 0.2, maxScaleExtent = 5;
   var graph, layout, zoom, nodes, links;
   var selectedContextNode, selectedDragNode;
   var linkedByIndex = {};
   var graphWidth, graphHeight;
   var data;

   var appOptions =
   {
      currentLevel: 0,
      currentScope: 'all', // Stores package / source scope: main, dev, all
      maxDepthSticky: true,
      showFullNames: false,
      showTableView: false
   };

   // Stores menu options that have a toggle state.
   var appMenuToggleOptions = ['maxDepthSticky', 'showFullNames', 'showTableView'];

   // Gathers data from template filled functions.
   var dataPackageMap =
   {
      'all': getPackageDataAll(),
      'dev': getPackageDataDev(),
      'main': getPackageDataMain()
   };

   // Provides a cache of recycled SVG elements.
   var svgElementMap =
   {
      circle: [],
      g: [],
      path: [],
      text: []
   };

   function cerialize(text)
   {
      var svgxml = (new XMLSerializer()).serializeToString(d3.select('svg').node());
      console.log('!!! serialize data -- text: ' + text);
      console.log('!!! svg: ' + svgxml);
      if (data)
      {
         console.log('!!! data.links: ' + JSON.stringify(data.links));
         console.log('!!! data.nodes: ' + JSON.stringify(data.nodes));
      }
   }

   /**
    * Bootstraps the setup of the graph.
    */
   function bootstrap()
   {
      // Hook up controllers
      $('.control-zoom button').on('click', onControlZoomClicked);
      $('.control-level input').on('change', onControlLevelChanged);
      $('.control-deps input').on('click', onControlDepsClicked);
      $('.control-links input').on('click', onControlLinksClicked);
      $('.control-menu li').on('click', onControlMenuClicked);

      $('#contextpopup li[data-action]').on('click', onNodeContextMenuClick);

      // Gather current level and scope from template values.
      appOptions.currentLevel = parseInt($('.control-level input').val());
      appOptions.currentScope = $('.control-deps input:radio[name=dep]:checked').val();

      zoom = d3.behavior.zoom();

      zoom.scaleExtent([minScaleExtent, maxScaleExtent]);
      zoom.on('zoom', onZoomChanged);

      graphWidth = window.innerWidth;
      graphHeight = window.innerHeight;

      d3.select(window).on('resize', onResize);

      // Setup layout
      layout = d3.layout.force()
       .gravity(.05)
       .charge(-300)
       .linkDistance(80)
       .size([graphWidth, graphHeight])
       .on('tick', onTick);

      // Setup drag callbacks for nodes. If a node is clicked and dragged it becomes fixed.
      layout.drag()
       .on('dragstart', function(targetNode)
       {
          d3.event.sourceEvent.stopPropagation();
          d3.select(this).classed('dragging', true).classed('fixed', targetNode.fixed = true);
          detectAllNodesFixed();
       })
       .on('drag', function(targetNode)
       {
          d3.select(this).attr('cx', targetNode.x = d3.event.x).attr('cy', targetNode.y = d3.event.y);
       })
       .on('dragend', function()
       {
          d3.select(this).classed('dragging', false);
       });

      // Setup graph
      d3.select('.graph')
       .append('svg')
       .attr('transform', 'rotate(0)')
       .on('contextmenu', function() { d3.event.preventDefault(); })
       .attr('pointer-events', 'all')
       .call(zoom).on('dblclick.zoom', null);

      // Markers Def
      d3.select('.graph svg')
       .append('defs').selectAll('marker')
       .data(['regular'])
       .enter().append('marker')
       .attr('id', String)
       .attr('viewBox', '0 -5 10 10')
       .attr('refX', 15)
       .attr('refY', -1.5)
       .attr('markerWidth', 6)
       .attr('markerHeight', 6)
       .attr('orient', 'auto')
       .append('path')
       .attr('d', 'M0,-5L10,0L0,5');

      // Top level SVGGElement for dragging / centering graph
      graph = d3.select('.graph svg')
       .append(getSVG('g'))
       .attr('width', graphWidth)
       .attr('height', graphHeight)
       .attr('transform', 'translate(' + zoom.translate() + ')' + ' scale(' + zoom.scale() + ')');

      // Initialize tablesorter
      $('#nodeTable').tablesorter(
      {
         widgets: ['stickyHeaders'],
         widgetOptions:
         {
            stickyHeaders_filteredToTop: true,
            stickyHeaders_cloneId : '-sticky',
            stickyHeaders_attachTo : '.control-table-inner'
         },
         sortMultiSortKey: ''
      });

      updateAll();

      // Center graph w/ zoom fit w/ 1 second transition applied after 4 seconds delay for debounce.
      centerGraph(zoomFit, 1000, 4000);
   }

   /**
    * Centers the graph. All parameters can be either a number or a function evaluated for a number result.
    *
    * `newScale` and `duration` are evaluated in the centering anonymous function allowing values to be determined
    * after debounce.
    *
    * @param {number|function}   newScale - New scale value for graph.
    * @param {number|function}   duration - Duration of centering transition.
    * @param {number|function}   delay - Delay for debounce before centering occurs.
    */
   function centerGraph(newScale, duration, delay)
   {
      if (typeof delay === 'function') { delay = delay.call(this); }

      delay = typeof delay === 'number' ? delay : 0;

      setTimeout(function()
      {
         if (typeof newScale === 'function') { newScale = newScale.call(this); }
         if (typeof duration === 'function') { duration = duration.call(this); }

         newScale = typeof newScale === 'number' ? newScale : zoom.scale();
         duration = typeof duration === 'number' ? duration : 200;

         if (typeof newScale !== 'number') { throw new TypeError("centerGraph error: 'newScale' is not a 'number'."); }
         if (typeof duration !== 'number') { throw new TypeError("centerGraph error: 'duration' is not a 'number'."); }

         var bounds = graph.node().getBBox();

         var centerSVGX = (graphWidth * newScale / 2);
         var centerSVGY = (graphHeight * newScale / 2);

         var centerGraphX = (bounds.x * newScale) + (bounds.width * newScale / 2);
         var centerGraphY = (bounds.y * newScale) + (bounds.height * newScale / 2);

         // Translate
         var centerTranslate =
         [
            (graphWidth / 2) - centerSVGX + (centerSVGX - centerGraphX),
            (graphHeight / 2) - centerSVGY + (centerSVGY - centerGraphY)
         ];

         // Store values
         zoom
          .translate(centerTranslate)
          .scale(newScale);

         // Render transition
         graph.transition()
          .duration(duration)
          .attr('transform', 'translate(' + zoom.translate() + ')' + ' scale(' + zoom.scale() + ')');

         // Hides any existing node context menu.
         hideNodeContextMenu();

      }, delay);
   }

   /**
    * Helper function to determin if all nodes are fixed. This is run after any node is dragged and set to fixed.
    */
   function detectAllNodesFixed()
   {
      if (data)
      {
         var currentNodesFixed = data.allNodesFixed;
         var allNodesFixed = true;
         data.nodes.forEach(function(node) { if (!node.fixed) { allNodesFixed = false; } });
         data.allNodesFixed = allNodesFixed;
         if (currentNodesFixed !== allNodesFixed) { updateMenuUI(); } // Update freeze / unfreeze menu option.
      }
   }

   /**
    * Fades and unfades connected nodes to a given `targetNode`.
    *
    * @param {object}   targetNode - The target node from which fading occurs / connections are calculated.
    * @param {boolean}  selected - Indicates if the fade is in / out; true fades nodes / false un-fades nodes.
    * @param {Array}    nodes - An array of all graph nodes.
    * @param {Array}    links - An array of all graph links.
    */
   function fadeRelatedNodes(targetNode, selected, nodes, links)
   {
      var opacity = selected ? 0.1 : 1;

      var elm = findElementByNode('circle', targetNode);

      // Highlight circle
      elm.classed('selected', opacity < 1);

      // Clean links
      $('path.link').removeAttr('data-show');

      // Traverse all nodes and set `dimmed` class to nodes that are dimmed / not connected in addition to setting
      // fill and stroke opacity.
      nodes.style('stroke-opacity', function(otherNode)
      {
         var thisOpacity = isConnected(targetNode, otherNode) ? 1 : opacity;

         this.setAttribute('fill-opacity', thisOpacity);
         this.setAttribute('stroke-opacity', thisOpacity);

         // Depending on opacity add or remove 'dimmed' class.
         this.classList[thisOpacity === 1 ? 'remove' : 'add']('dimmed');

         return thisOpacity;
      });

      // Traverse all links and set `data-show` and `marker-end` for connected links given the `targetNode`.
      links.style('stroke-opacity', function(otherNode)
      {
         if (otherNode.source === targetNode)
         {
            // Highlight target / sources of the link
            var elmNodes = graph.selectAll('.' + formatClassName('node', otherNode.target));
            elmNodes.attr('fill-opacity', 1);
            elmNodes.attr('stroke-opacity', 1);

            elmNodes.classed('dimmed', false);

            // Highlight arrows
            var elmCurrentLink = $('path.link[data-source=' + otherNode.source.index + ']');
            elmCurrentLink.attr('data-show', true);
            elmCurrentLink.attr('marker-end', 'url(#regular)');

            return 1;
         }
         else
         {
            return opacity;
         }
      });

      // Modify all links that have not had 'data-show' added above.
      var elmAllLinks = $('path.link:not([data-show])');
      elmAllLinks.attr('marker-end', opacity === 1 ? 'url(#regular)' : '');
   }

   /**
    * A helper to select a given SVG element from given node data.
    *
    * @param {string}   prefix - String prefix.
    * @param {object}   node - Node object
    */
   function findElementByNode(prefix, node)
   {
      var selector = '.' + formatClassName(prefix, node);
      return graph.select(selector);
   }

   /**
    * Replaces semver and other special characters with `-`.
    *
    * @param {string}   prefix - String prefix.
    * @param {object}   node - Node object
    * @returns {string}
    */
   function formatClassName(prefix, node)
   {
      return prefix + '-' + node.id;
   }

   /**
    * Pass in the element and the screen coordinates are returned.
    *
    * @param element
    *
    * @returns {{x: number, y: number}}
    */
   function getElementCoords(element)
   {
      var ctm = element.getCTM();

      return { x: ctm.e + element.getAttribute('cx') * ctm.a, y: ctm.f + element.getAttribute('cy') * ctm.d };
   }

   /**
    * Gets a recycled SVG element from the pool, `svgElementMap`, or creates a new element for the given type. Any
    * data specified by D3 will be copied to the element. Returns a function which is evaluated by D3.
    *
    * @param {string}   elementType - SVG element: `circle`, `g`, `path`, or `text`.
    *
    * @returns {*}
    */
   function getSVG(elementType)
   {
      var returnVal;
      var svgElement;
      var cached;

      switch (elementType)
      {
         case 'circle':
         case 'g':
         case 'path':
         case 'text':
            returnVal = function(data)
            {
               svgElement = svgElementMap[elementType].pop();

               cached = svgElement != null;

               svgElement = svgElement != null ? svgElement : document.createElementNS('http://www.w3.org/2000/svg',
                elementType);

               // Copy data to SVG element.
               if (typeof data === 'object') { for (var key in data) { svgElement.setAttribute(key, data[key]); } }

               return svgElement;
            };
            break;

         default:
            throw new TypeError('getSVG error: unknown elementType.');
      }

      return returnVal;
   }

   /**
    * Hides the node context menu if visible and removes any node highlighting. If an event is supplied it is checked
    * against any existing context menu and is ignored if the context menu is within the parent hierarchy.
    *
    * @param {object|undefined}  event - Optional event
    */
   function hideNodeContextMenu(event)
   {
      // Provide an early out if there is no selected context node.
      if (typeof selectedContextNode === 'undefined') { return; }

      var contextMenuButton = $('#context-menu');
      var popupmenu = $('#contextpopup .mdl-menu__container');

      // If an event is defined then make sure it isn't targeting the context menu.
      if (event)
      {
         event.preventDefault();

         // Picked element is not the menu
         if (!$(event.target).parents('#contextpopup').length > 0)
         {
            // Hide menu if currently visible
            if (popupmenu.hasClass('is-visible')) { contextMenuButton.click(); }

            fadeRelatedNodes(selectedContextNode, false, nodes, links);
            selectedContextNode = undefined;
         }
      }
      else // No event defined so always close context menu and remove node highlighting.
      {
         // Hide menu if currently visible
         if (popupmenu.hasClass('is-visible')) { contextMenuButton.click(); }

         fadeRelatedNodes(selectedContextNode, false, nodes, links);
         selectedContextNode = undefined;
      }
   }

   /**
    * Checks if a target node is connected to another given node by checking `index` or the `linkedByIndex` map.
    *
    * @param {object}   targetNode
    * @param {object}   otherNode
    *
    * @returns {boolean}
    */
   function isConnected(targetNode, otherNode)
   {
      return targetNode.index === otherNode.index || linkedByIndex[targetNode.index + ',' + otherNode.index];
   }

   /**
    * Returns whether there is a currently selected node (drag or context).
    *
    * @returns {boolean}
    */
   function isNodeSelected()
   {
      return typeof selectedDragNode !== 'undefined' || typeof selectedContextNode !== 'undefined';
   }

   /**
    * Handles responding to the dependencies radio group.
    */
   function onControlDepsClicked()
   {
      // Do nothing if scope has not changed
      if (this.value === appOptions.currentScope) { return; }

      // If max depth is set to sticky and current level is equal max level of old scope then set max level for
      // the new scope.
      if (appOptions.maxDepthSticky && appOptions.currentLevel === dataPackageMap[appOptions.currentScope].maxLevel)
      {
         appOptions.currentLevel = dataPackageMap[this.value].maxLevel
      }

      appOptions.currentScope = this.value;

      var maxLevel = dataPackageMap[appOptions.currentScope].maxLevel;

      // Adjust current level if it is greater than max level for current scope.
      if (appOptions.currentLevel > maxLevel) { appOptions.currentLevel = maxLevel; }

      // Update control level UI based on current and max level for given scope.
      $('.control-level input').attr({ max: maxLevel });
      $('.control-level input').val(appOptions.currentLevel);
      $('.control-level label').html(appOptions.currentLevel);

      // Redraw graph data
      updateAll({ redrawOnly: true });

      // Center graph w/ zoom fit w/ 1 second transition applied after a potential 2 seconds delay for debounce.
      centerGraph(zoomFit, 1000, data.allNodesFixed ? 0 : 2000);
   }

   /**
    * Handles responding to the level slider.
    */
   function onControlLevelChanged()
   {
      appOptions.currentLevel = parseInt(this.value);

      $('.control-level input').val(appOptions.currentLevel);
      $('.control-level label').html(appOptions.currentLevel);

      // Redraw graph data
      updateAll({ redrawOnly: true });

      // Center graph w/ zoom fit w/ 1 second transition applied after a potential 2 seconds delay for debounce.
      centerGraph(zoomFit, 1000, data.allNodesFixed ? 0 : 2000);
   }

   /**
    * Handles reverse links input reversing the graph links then redrawing the graph.
    */
   function onControlLinksClicked()
   {
      reverseGraphLinks();

      renderGraph({ redrawOnly: true });
   }

   /**
    * Handles responding to overflow menu selections.
    */
   function onControlMenuClicked()
   {
      switch ($(this).data('action'))
      {
         case 'toggleFreezeAllNodes':
            setNodesFixed(!data.allNodesFixed);
            break;

         case 'showFullNames':
            appOptions.showFullNames = !appOptions.showFullNames;
            updateAll({ redrawOnly: true });
            break;

         case 'showTableView':
            appOptions.showTableView = !appOptions.showTableView;
            $('.control-table').toggleClass('hidden', !appOptions.showTableView);
            updateTableUIExtent();
            break;

         case 'maxDepthSticky':
            appOptions.maxDepthSticky = !appOptions.maxDepthSticky;
            break;
      }

      // Defer updating menu UI until menu is hidden.
      setTimeout(updateMenuUI, 200);
   }

   /**
    * Handles a context click on a table row showing the related node context menu.
    *
    * @param {object}   node - Target node.
    * @param {object}   event - mouse event
    */
   function onControlTableRowContextClick(node, event)
   {
      event.preventDefault(); // Prevents default browser context menu from showing.
      onNodeContextClick(node, { x: event.pageX, y: event.pageY });
   }

   /**
    * Handles a context click on a table row showing the related node context menu. Defers to `onNodeMouseOverOut`.
    *
    * @param {Array}    nodes - All graph nodes.
    * @param {Array}    links - All graph links.
    * @param {object}   node - Target node.
    * @param {boolean}  enter - true when mouse entering / false when mouse exiting.
    */
   function onControlTableRowMouseOver(nodes, links, node, enter)
   {
      // Hide the node context menu if currently showing when a new table row / node is moused over.
      if (node !== selectedContextNode) { hideNodeContextMenu(event); }

      onNodeMouseOverOut(nodes, links, enter, node);
   }

   /**
    * Handles clicks on zoom control buttons and invokes `centerGraph` with new scale value.
    */
   function onControlZoomClicked()
   {
      var newScale = 1;
      var scalePercentile = 0.20;

      // Add or subtract scale percentile from current scale value.
      switch ($(this).data('action'))
      {
         case 'zoom_in':
            newScale = Math.max(Math.min(zoom.scale() * (1 + scalePercentile), maxScaleExtent), minScaleExtent);
            break;

         case 'zoom_out':
            newScale = Math.max(zoom.scale() * (1 - scalePercentile), minScaleExtent);
            break;

         case 'zoom_all_out':
            newScale = zoomFit();
            break;
      }

      centerGraph(newScale);
   }

   /**
    * Handles clicks on the node context menu invoking any active actions.
    */
   function onNodeContextMenuClick()
   {
      // When a context menu is selected remove node highlighting.
      hideNodeContextMenu();

      switch ($(this).data('action'))
      {
         case 'openSCMLink':
            var link = $(this).data('extra');

            if (typeof link === 'string')
            {
               window.open(link, '_blank', 'location=yes,menubar=yes,scrollbars=yes,status=yes');
            }
            break;
      }
   }

   /**
    * Shows the node context menu
    *
    * @param {object}   targetNode - The target node.
    *
    * @param {object}   coords - Object containing x / y position for context menu; if not provided Node position
    *                            determines coords.
    */
   function onNodeContextClick(targetNode, coords)
   {
      // Hides any existing node context menu.
      hideNodeContextMenu();

      if (typeof coords !== 'object') { coords = getElementCoords(this); }

      var popupmenu = $('#contextpopup .mdl-menu__container');

      // Populate data for the context menu.
      popupmenu.find('li').each(function( index )
      {
         switch (index)
         {
            case 0:
               $(this).text('Open on ' + targetNode.packageData.type);
               $(this).data('extra', targetNode.packageData.link);
               break;

            case 1:
               $(this).text('Fullname: ' + targetNode.packageData.fullName);
               break;

            case 2:
               $(this).text('Version: ' + targetNode.packageData.version);
               break;
         }
      });

      // Wrapping in a 100ms timeout allows MDL to draw animation when showing a context menu after one has been hidden.
      setTimeout(function()
      {
         // Assign new selected context node and highlight related nodes.
         selectedContextNode = targetNode;

         fadeRelatedNodes(selectedContextNode, true, nodes, links);

         // For MDL a programmatic click of the hidden context menu.
         var contextMenuButton = $("#context-menu");
         contextMenuButton.click();

         // Necessary to defer reposition of the context menu.
         setTimeout(function()
         {
            popupmenu.parent().css({ position: 'relative' });
            popupmenu.css({ left: coords.x, top: coords.y, position:'absolute' });
         }, 0);
      }, 100);
   }

   /**
    * Handles a mouse down action on a graph node. Hides any showing context menu. For left clicks the selected node
    * becomes the drag target and related nodes are faded. Any other mouse button is ignored.
    *
    * @param {Array}    nodes - All graph nodes.
    * @param {Array}    links - All graph links.
    * @param {object}   targetNode - The target node.
    */
   function onNodeMouseDown(nodes, links, targetNode)
   {
      hideNodeContextMenu();

      // Only select / drag nodes with left clicked otherwise stop propagation of event.
      if (d3.event.button === 0)
      {
         selectedDragNode = targetNode;

         // Select / highlight related nodes or remove attributes based on enter state.
         fadeRelatedNodes(targetNode, true, nodes, links);
      }
      else
      {
         d3.event.stopPropagation();
      }
   }

   /**
    * Handles fading related nodes to the given `targetNode` if there is no currently selected node.
    *
    * @param {Array}    nodes - All graph nodes.
    * @param {Array}    links - All graph links.
    * @param {boolean}  enter - true when mouse entering / false when mouse exiting.
    * @param {object}   targetNode - The target node.
    */
   function onNodeMouseOverOut(nodes, links, enter, targetNode)
   {
      // If there is an existing selected node then exit early.
      if (isNodeSelected()) { return; }

      // Select / highlight related nodes or remove attributes based on enter state.
      fadeRelatedNodes(targetNode, enter, nodes, links);
   }

   /**
    * Handles the window resize event.
    */
   function onResize()
   {
      // Update graph parameters.
      graphWidth = window.innerWidth;
      graphHeight = window.innerHeight;

      graph.attr('width', graphWidth).attr('height', graphHeight);

      layout.size([graphWidth, graphHeight]).resume();

      updateMenuUI();

      updateTableUIExtent();

      // Hides any existing node context menu.
      hideNodeContextMenu();

      centerGraph(zoomFit, 1000, data.allNodesFixed ? 0 : 2000);
   }

   /**
    * D3 tick handler for the forced graph layout.
    */
   function onTick()
   {
      nodes.attr('cx', function(node) { return node.x; })
       .attr('cy', function(node) { return node.y; })
       .attr('transform', function(node) { return 'translate(' + node.x + ',' + node.y + ')'; });

      // Pull data from data.nodes array. Provides a curve to the links.
      links.attr('d', function(link)
      {
         var sourceX = data.nodes[link.source.index].x;
         var sourceY = data.nodes[link.source.index].y;
         var targetX = data.nodes[link.target.index].x;
         var targetY = data.nodes[link.target.index].y;

         var dx = targetX - sourceX,
          dy = targetY - sourceY,
          dr = Math.sqrt(dx * dx + dy * dy);
         return 'M' + sourceX + ',' + sourceY + 'A' + dr + ',' + dr + ' 0 0,1 ' + targetX + ',' + targetY;
      });
   }

   /**
    * Handles the D3 zoom / scale event.
    */
   function onZoomChanged()
   {
      var newScale = Math.max(d3.event.scale, minScaleExtent);

      zoom.scale(newScale);

      graph.attr('transform', 'translate(' + d3.event.translate + ')' + ' scale(' + newScale + ')');
   }

   /**
    * Recycles all SVG elements above the top level SVGGElement defining the graph.
    */
   function recycleGraph()
   {
      var childNodes = graph.selectAll('g > *').remove();

      if (!Array.isArray(childNodes) && !Array.isArray(childNodes['0'])) { return; }

      // Get the child nodes group from selection.
      childNodes = childNodes['0'];

      for (var cntr = 0; cntr < childNodes.length; cntr++)
      {
         var childNode = childNodes[cntr];

         if (childNode instanceof SVGPathElement) { svgElementMap['path'].push(childNode); }
         else if (childNode instanceof SVGCircleElement) { svgElementMap['circle'].push(childNode); }
         else if (childNode instanceof SVGTextElement) { svgElementMap['text'].push(childNode); }
         else if (childNode instanceof SVGGElement)
         {
            childNode.removeAttribute('transform');  // Must remove current transform.
            svgElementMap['g'].push(childNode);
         }
      }
   }

   /**
    * Renders the graph after recycling any nodes above the top level `g` SVGGElement.
    *
    * @param {object}   options - Optional parameters:
    * ```
    * (boolean)   redrawOnly - sets layout.alpha to a low value to reduce bounce.
    * ```
    */
   function renderGraph(options)
   {
      options = typeof options === 'object' ? options : {};
      options.redrawOnly = typeof options.redrawOnly === 'boolean' ? options.redrawOnly : false;

      // Recycle all SVG elements above the first SVGGElement.
      recycleGraph();

      // Lines
      // Note: on second render link.source / target will be an object instead of a number.
      links = graph.append(getSVG('g')).selectAll('line')
       .data(data.links)
       .enter().append(getSVG('path'))
       .attr('class', 'link')
       .attr('marker-end', function() { return 'url(#regular)'; })
       .attr('data-source', function(link)
       {
          return typeof link.source === 'number' ? link.source : link.source.index;
       })
       .attr('data-target', function(link)
       {
          return typeof link.target === 'number' ? link.target : link.target.index;
       });

      // Nodes
      nodes = graph.append(getSVG('g')).selectAll('node')
       .data(data.nodes)
       .enter().append(getSVG('g'))
       .call(layout.drag)
       .attr('class', 'node');

      // Circles
      nodes.attr('class', function(node) { return formatClassName('node', node); });
      nodes.append(getSVG('circle'))
       .attr('id', function(node) { return formatClassName('id', node); })
       .attr('class', function(node) { return formatClassName('circle', node) + ' ' + node.packageData.type; })
       .attr('r', circleRadius)
       .on('contextmenu', onNodeContextClick)
       .on('mousedown', onNodeMouseDown.bind(this, nodes, links))
       .on('mouseover', onNodeMouseOverOut.bind(this, nodes, links, true))
       .on('mouseout', onNodeMouseOverOut.bind(this, nodes, links, false))
       .on('dblclick.zoom', function(node) // Centers view on node.
       {
          d3.event.stopPropagation();

          var dcx = (window.innerWidth / 2 - node.x * zoom.scale());
          var dcy = (window.innerHeight / 2 - node.y * zoom.scale());

          zoom.translate([dcx, dcy]);

          graph.transition()
           .duration(500)
           .attr('transform', 'translate('+ dcx + ',' + dcy  + ')scale(' + zoom.scale() + ')');
       });

      // A copy of the text with a thick white stroke for legibility.
      nodes.append(getSVG('text'))
       .attr('x', 15)
       .attr('y', '.31em')
       .attr('class', function(node) { return 'shadow ' + formatClassName('text', node); })
       .text(function(node)
       {
          return (appOptions.showFullNames ? node.packageData.fullName : node.packageData.name) +
           ' (' + node.minLevel +')';
       });

      nodes.append(getSVG('text'))
       .attr('class', function(node)
       {
          return node.packageData.isAliased ? 'isAliased ' : '' + formatClassName('text', node);
       })
       .attr('x', 15)
       .attr('y', '.31em')
       .text(function(node)
       {
          return (appOptions.showFullNames ? node.packageData.fullName : node.packageData.name) +
           ' (' + node.minLevel +')';
       });

      // Set the force layout nodes / links and start the bounce.
      layout.nodes(data.nodes);
      layout.links(data.links);
      layout.start();

      linkedByIndex = {};

      // Build linked index
      data.links.forEach(function(node) { linkedByIndex[node.source.index + ',' + node.target.index] = true; });

      // Set a low alpha to provide minimal bounce when just redrawing.
      if (options.redrawOnly) { layout.alpha(0.01); }
   }

   /**
    * Reverses all graph links.
    */
   function reverseGraphLinks()
   {
      for (var key in dataPackageMap)
      {
         var graphData = dataPackageMap[key];

         graphData.links.forEach(function(link)
         {
            var linkSource = link.source;
            link.source = link.target;
            link.target = linkSource;
         });
      }
   }

   /**
    * Sets all nodes fixed (freeze) or unfixed (unfreeze).
    *
    * @param {boolean}  fixed - Fixed state for all nodes.
    */
   function setNodesFixed(fixed)
   {
      // Resets any fixed node state.
      if (nodes) { nodes.each(function(node) { d3.select(this).classed('fixed', node.fixed = fixed); }); }

      // Copy existing sim data to any package scope that contains the same node ID.
      for (var key in dataPackageMap) { dataPackageMap[key].nodes.forEach(function(node) { node.fixed = fixed; }); }

      if (data) { data.allNodesFixed = fixed; }
   }

   /**
    * Helper function that simply defers to the standard update / render process.
    *
    * @param renderOptions
    */
   function updateAll(renderOptions)
   {
      // Load graph data
      updateGraphData();

      renderGraph(renderOptions);

      updateMenuUI();

      updateTableUI();
   }

   /**
    * Filters graph data based on current app option parameters: `currentScope` and `currentLevel`.
    */
   function updateGraphData()
   {
      // Copy existing data / node parameters to new filtered data;
      if (data)
      {
         var existingNodeSimMap = {};

         // Collect existing simulation data.
         data.nodes.forEach(function(node)
         {
            existingNodeSimMap[node.id] =
            {
               weight: node.weight,
               x: node.x,
               y: node.y,
               px: node.px,
               py: node.py,
               fixed: node.fixed ? node.fixed : false
            };
         });

         // Copy existing sim data to any package scope that contains the same node ID.
         for (var mapKey in dataPackageMap)
         {
            var graphData = dataPackageMap[mapKey];

            graphData.nodes.forEach(function(node)
            {
               if (existingNodeSimMap[node.id])
               {
                  for (var key in existingNodeSimMap[node.id]) { node[key] = existingNodeSimMap[node.id][key]; }
               }
            });
         }
      }

      var allNodesFixed = true;

      // Set new data
      data =
      {
         directed: dataPackageMap[appOptions.currentScope].directed,
         multigraph: dataPackageMap[appOptions.currentScope].multigraph,
         graph: dataPackageMap[appOptions.currentScope].graph,
         links: dataPackageMap[appOptions.currentScope].links.filter(function(link)
         {
            return link.minLevel <= appOptions.currentLevel;
         }),
         nodes: dataPackageMap[appOptions.currentScope].nodes.filter(function(node)
         {
            if (typeof node.fixed === 'undefined' || node.fixed === false) { allNodesFixed = false; }
            return node.minLevel <= appOptions.currentLevel;
         })
      };

      data.allNodesFixed = allNodesFixed;
   }

   /**
    * Provides handling of changing menu text & material icons based on current state.
    */
   function updateMenuUI()
   {
      if (data)
      {
         $('.control-menu li[data-action=toggleFreezeAllNodes]').html(data.allNodesFixed ?
          'Unfreeze nodes' : 'Freeze nodes');
      }

      appMenuToggleOptions.forEach(function(key)
      {
         var icon = appOptions[key] ? 'check_box' : 'check_box_outline_blank';
         $('.control-menu li[data-action=' + key + '] i').html(icon);
      });
   }

   /**
    * Builds the table UI with all current node data and associates the active events on each row.
    */
   function updateTableUI()
   {
      var table = $('.control-table tbody');

      table.off('mouseenter', 'tr', onControlTableRowMouseOver);
      table.off('mouseleave', 'tr', onControlTableRowMouseOver);
      table.off('contextmenu', 'tr', onControlTableRowContextClick);

      table.empty();

      if (data)
      {
         data.nodes.forEach(function(node)
         {
            var nd = node.packageData;
            var name = appOptions.showFullNames ? nd.fullName : nd.name;
            var isAliased = nd.isAliased ? ' isAliased' : '';

            var tr = $(
             '<tr>' +
                '<td class="mdl-data-table__cell--non-numeric' + isAliased + '">' + name + '</td>' +
                '<td class="mdl-data-table__cell--non-numeric">' + nd.type + '</td>' +
                '<td class="mdl-data-table__cell--non-numeric">' + nd.version + '</td>' +
                '<td class="mdl-data-table__cell--non-numeric">' + node.minLevel + '</td>' +
             '</tr>');

            table.append(tr);

            tr.on('mouseenter', onControlTableRowMouseOver.bind(this, nodes, links, node, true));
            tr.on('mouseleave', onControlTableRowMouseOver.bind(this, nodes, links, node, false));
            tr.on('contextmenu', onControlTableRowContextClick.bind(this, node));
         });

         // Removes sort order for any header and signals update for new data
         $('#nodeTable th').removeClass('headerSortDown');
         $('#nodeTable th').removeClass('headerSortUp');
         $('#nodeTable').trigger('update');

         updateTableUIExtent();
      }
   }

   /**
    * Updates the node table max-height enabling scrolling as necessary.
    */
   function updateTableUIExtent()
   {
      var tableDiv = $('.control-table-inner');
      var nodeTable = $('#nodeTable');

      var tableHeight = nodeTable.height();

      var offset = tableDiv.offset();
      var maxTableHeight = window.innerHeight - offset.top - 20;

      tableDiv.css('max-height', maxTableHeight);
      nodeTable.css('margin-right', tableHeight > maxTableHeight ? '10px' : '0px');
   }

   /**
    * Determines a new scale that fits the entire graph into view.
    *
    * @returns {number}
    */
   function zoomFit()
   {
      var bounds = graph.node().getBBox();
      var parent = graph.node().parentElement;
      var fullWidth = parent.clientWidth, fullHeight = parent.clientHeight;
      var width = bounds.width, height = bounds.height;

      if (width === 0 || height === 0) { return 1; } // nothing to fit

      var scale = 0.75 / Math.max(width / fullWidth, height / fullHeight);

      scale = Math.max(Math.min(scale, maxScaleExtent), minScaleExtent);

      return scale;
   }

   // Prevent default browser context menu from being triggered.
   $(document).bind('contextmenu', function(event) { event.preventDefault(); });

   // Properly handle closing context menu when document mouse down clicked
   // This works when a node context click occurs because the new context menu is shown with a small timeout.
   $(document).bind('mousedown', hideNodeContextMenu);

   /**
    * This function removes the selected drag node highlighting if document mouse up event occurs outside the window
    * bounds the distance between the document mouse up value is greater than the radius of the current location
    * of the circle SVG element.
    */
   $(document).bind('mouseup', function(event)
   {
      if (typeof selectedDragNode !== 'undefined')
      {
         var pageX = event.pageX;
         var pageY = event.pageY;

         // Detect a drag / mouse up outside window bounds and automatically reset.
         if (pageX < 0 || pageY < 0 || pageX > window.innerWidth || pageY > window.innerHeight)
         {
            fadeRelatedNodes(selectedDragNode, false, nodes, links);
            selectedDragNode = undefined;
            return;
         }

         // Otherwise verify if the mouse up distance is greater than the SVGCircleElement location.

         var elm = findElementByNode('circle', selectedDragNode);

         var coords = getElementCoords(elm.node());

         var a = pageX - coords.x;
         var b = pageY - coords.y;

         var distance = Math.sqrt(a * a + b * b);

         // Remove node highlight and related nodes
         if (distance > circleRadius) { fadeRelatedNodes(selectedDragNode, false, nodes, links); }

         selectedDragNode = undefined;
      }
   });

   bootstrap();
})();
</script>

</body>
</html>